// Generated by CoffeeScript 1.9.3
(function() {
  var assert, http, https, path, remote, ws;

  assert = require('assert');

  http = require('http');

  https = require('https');

  path = require('path');

  ws = require('ws');

  remote = require('remote');

  describe('chromium feature', function() {
    var fixtures;
    fixtures = path.resolve(__dirname, 'fixtures');
    describe('heap snapshot', function() {
      return it('does not crash', function() {
        return process.atomBinding('v8_util').takeHeapSnapshot();
      });
    });
    describe('sending request of http protocol urls', function() {
      return it('does not crash', function(done) {
        var server;
        this.timeout(5000);
        server = http.createServer(function(req, res) {
          res.end();
          server.close();
          return done();
        });
        return server.listen(0, '127.0.0.1', function() {
          var port;
          port = server.address().port;
          return $.get("http://127.0.0.1:" + port);
        });
      });
    });
    describe('navigator.webkitGetUserMedia', function() {
      return it('calls its callbacks', function(done) {
        this.timeout(5000);
        return navigator.webkitGetUserMedia({
          audio: true,
          video: false
        }, function() {
          return done();
        }, function() {
          return done();
        });
      });
    });
    describe('navigator.language', function() {
      return it('should not be empty', function() {
        return assert.notEqual(navigator.language, '');
      });
    });
    describe('window.open', function() {
      return it('returns a BrowserWindowProxy object', function() {
        var b;
        b = window.open('about:blank', 'test', 'show=no');
        assert.equal(b.closed, false);
        assert.equal(b.constructor.name, 'BrowserWindowProxy');
        return b.close();
      });
    });
    describe('window.opener', function() {
      var ipc, url, w;
      ipc = remote.require('ipc');
      url = "file://" + fixtures + "/pages/window-opener.html";
      w = null;
      afterEach(function() {
        if (w != null) {
          w.destroy();
        }
        return ipc.removeAllListeners('opener');
      });
      it('is null for main window', function(done) {
        var BrowserWindow;
        ipc.on('opener', function(event, opener) {
          return done(opener === null ? void 0 : opener);
        });
        BrowserWindow = remote.require('browser-window');
        w = new BrowserWindow({
          show: false
        });
        return w.loadUrl(url);
      });
      return it('is not null for window opened by window.open', function(done) {
        var b;
        b = window.open(url, 'test2', 'show=no');
        return ipc.on('opener', function(event, opener) {
          b.close();
          return done(opener !== null ? void 0 : opener);
        });
      });
    });
    describe('creating a Uint8Array under browser side', function() {
      return it('does not crash', function() {
        var RUint8Array;
        RUint8Array = remote.getGlobal('Uint8Array');
        return new RUint8Array;
      });
    });
    describe('webgl', function() {
      return it('can be get as context in canvas', function() {
        var webgl;
        if (process.platform === 'linux') {
          return;
        }
        webgl = document.createElement('canvas').getContext('webgl');
        return assert.notEqual(webgl, null);
      });
    });
    describe('web workers', function() {
      it('Worker can work', function(done) {
        var message, worker;
        worker = new Worker('../fixtures/workers/worker.js');
        message = 'ping';
        worker.onmessage = function(event) {
          assert.equal(event.data, message);
          worker.terminate();
          return done();
        };
        return worker.postMessage(message);
      });
      return it('SharedWorker can work', function(done) {
        var message, worker;
        worker = new SharedWorker('../fixtures/workers/shared_worker.js');
        message = 'ping';
        worker.port.onmessage = function(event) {
          assert.equal(event.data, message);
          return done();
        };
        return worker.port.postMessage(message);
      });
    });
    describe('iframe', function() {
      var iframe;
      iframe = null;
      beforeEach(function() {
        return iframe = document.createElement('iframe');
      });
      afterEach(function() {
        return document.body.removeChild(iframe);
      });
      return it('does not have node integration', function(done) {
        iframe.src = "file://" + fixtures + "/pages/set-global.html";
        document.body.appendChild(iframe);
        return iframe.onload = function() {
          assert.equal(iframe.contentWindow.test, 'undefined undefined undefined');
          return done();
        };
      });
    });
    describe('storage', function() {
      return it('requesting persitent quota works', function(done) {
        return navigator.webkitPersistentStorage.requestQuota(1024 * 1024, function(grantedBytes) {
          assert.equal(grantedBytes, 1048576);
          return done();
        });
      });
    });
    describe('websockets', function() {
      var WebSocketServer, server, wss;
      wss = null;
      server = null;
      WebSocketServer = ws.Server;
      afterEach(function() {
        wss.close();
        return server.close();
      });
      return it('has user agent', function(done) {
        server = http.createServer();
        return server.listen(0, '127.0.0.1', function() {
          var port, websocket;
          port = server.address().port;
          wss = new WebSocketServer({
            server: server
          });
          wss.on('error', done);
          wss.on('connection', function(ws) {
            if (ws.upgradeReq.headers['user-agent']) {
              return done();
            } else {
              return done('user agent is empty');
            }
          });
          return websocket = new WebSocket("ws://127.0.0.1:" + port);
        });
      });
    });
    return describe('Promise', function() {
      it('resolves correctly in Node.js calls', function(done) {
        document.registerElement('x-element', {
          prototype: Object.create(HTMLElement.prototype, {
            createdCallback: {
              value: function() {}
            }
          })
        });
        return setImmediate(function() {
          var called;
          called = false;
          Promise.resolve().then(function() {
            return done(called ? void 0 : new Error('wrong sequnce'));
          });
          document.createElement('x-element');
          return called = true;
        });
      });
      return it('resolves correctly in Electron calls', function(done) {
        document.registerElement('y-element', {
          prototype: Object.create(HTMLElement.prototype, {
            createdCallback: {
              value: function() {}
            }
          })
        });
        return remote.getGlobal('setImmediate')(function() {
          var called;
          called = false;
          Promise.resolve().then(function() {
            return done(called ? void 0 : new Error('wrong sequnce'));
          });
          document.createElement('y-element');
          return called = true;
        });
      });
    });
  });

}).call(this);
