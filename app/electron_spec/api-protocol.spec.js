// Generated by CoffeeScript 1.9.3
(function() {
  var assert, http, ipc, path, protocol, remote;

  assert = require('assert');

  ipc = require('ipc');

  http = require('http');

  path = require('path');

  remote = require('remote');

  protocol = remote.require('protocol');

  describe('protocol module', function() {
    describe('protocol.registerProtocol', function() {
      it('error when scheme is already registered', function(done) {
        var register;
        register = function() {
          return protocol.registerProtocol('test1', (function(request) {}), function(error, scheme) {
            if (error != null) {
              return protocol.unregisterProtocol('test1', function(error, scheme) {
                assert.equal(scheme, 'test1');
                return done();
              });
            } else {
              assert.equal(scheme, 'test1');
              return register();
            }
          });
        };
        return register();
      });
      return it('calls the callback when scheme is visited', function(done) {
        protocol.registerProtocol('test2', function(request) {
          assert.equal(request.url, 'test2://test2');
          protocol.unregisterProtocol('test2');
          return done();
        });
        return $.get('test2://test2', function() {});
      });
    });
    describe('protocol.unregisterProtocol', function() {
      return it('throws error when scheme does not exist', function() {
        return protocol.unregisterProtocol('test3', (function() {}), function(error, scheme) {
          if (error) {
            assert.equal(scheme, 'test3');
            return done();
          }
        });
      });
    });
    describe('registered protocol callback', function() {
      it('returns string should send the string as request content', function(done) {
        var handler;
        handler = remote.createFunctionWithReturnValue('valar morghulis');
        protocol.registerProtocol('atom-string', handler);
        return $.ajax({
          url: 'atom-string://fake-host',
          success: function(data) {
            assert.equal(data, handler());
            protocol.unregisterProtocol('atom-string');
            return done();
          },
          error: function(xhr, errorType, error) {
            assert(false, 'Got error: ' + errorType + ' ' + error);
            return protocol.unregisterProtocol('atom-string');
          }
        });
      });
      it('returns RequestStringJob should send string', function(done) {
        var data, handler, job;
        data = 'valar morghulis';
        job = new protocol.RequestStringJob({
          mimeType: 'text/html',
          data: data
        });
        handler = remote.createFunctionWithReturnValue(job);
        protocol.registerProtocol('atom-string-job', handler);
        return $.ajax({
          url: 'atom-string-job://fake-host',
          success: function(response) {
            assert.equal(response, data);
            protocol.unregisterProtocol('atom-string-job');
            return done();
          },
          error: function(xhr, errorType, error) {
            assert(false, 'Got error: ' + errorType + ' ' + error);
            return protocol.unregisterProtocol('atom-string-job');
          }
        });
      });
      it('returns RequestErrorJob should send error', function(done) {
        var data, handler, job;
        data = 'valar morghulis';
        job = new protocol.RequestErrorJob(-6);
        handler = remote.createFunctionWithReturnValue(job);
        protocol.registerProtocol('atom-error-job', handler);
        return $.ajax({
          url: 'atom-error-job://fake-host',
          success: function(response) {
            return assert(false, 'should not reach here');
          },
          error: function(xhr, errorType, error) {
            assert(errorType, 'error');
            protocol.unregisterProtocol('atom-error-job');
            return done();
          }
        });
      });
      it('returns RequestHttpJob should send respone', function(done) {
        var server;
        server = http.createServer(function(req, res) {
          assert.notEqual(req.headers.accept, '');
          res.writeHead(200, {
            'Content-Type': 'text/plain'
          });
          res.end('hello');
          return server.close();
        });
        return server.listen(0, '127.0.0.1', function() {
          var handler, job, port, url;
          port = server.address().port;
          url = "http://127.0.0.1:" + port;
          job = new protocol.RequestHttpJob({
            url: url
          });
          handler = remote.createFunctionWithReturnValue(job);
          protocol.registerProtocol('atom-http-job', handler);
          return $.ajax({
            url: 'atom-http-job://fake-host',
            success: function(data) {
              assert.equal(data, 'hello');
              protocol.unregisterProtocol('atom-http-job');
              return done();
            },
            error: function(xhr, errorType, error) {
              assert(false, 'Got error: ' + errorType + ' ' + error);
              return protocol.unregisterProtocol('atom-http-job');
            }
          });
        });
      });
      it('returns RequestBufferJob should send buffer', function(done) {
        var data, handler, job;
        data = new Buffer("hello");
        job = new protocol.RequestBufferJob({
          data: data
        });
        handler = remote.createFunctionWithReturnValue(job);
        protocol.registerProtocol('atom-buffer-job', handler);
        return $.ajax({
          url: 'atom-buffer-job://fake-host',
          success: function(response) {
            var buf;
            assert.equal(response.length, data.length);
            buf = new Buffer(response.length);
            buf.write(response);
            assert(buf.equals(data));
            protocol.unregisterProtocol('atom-buffer-job');
            return done();
          },
          error: function(xhr, errorType, error) {
            assert(false, 'Got error: ' + errorType + ' ' + error);
            return protocol.unregisterProtocol('atom-buffer-job');
          }
        });
      });
      it('returns RequestFileJob should send file', function(done) {
        var handler, job;
        job = new protocol.RequestFileJob(__filename);
        handler = remote.createFunctionWithReturnValue(job);
        protocol.registerProtocol('atom-file-job', handler);
        return $.ajax({
          url: 'atom-file-job://' + __filename,
          success: function(data) {
            var content;
            content = require('fs').readFileSync(__filename);
            assert.equal(data, String(content));
            protocol.unregisterProtocol('atom-file-job');
            return done();
          },
          error: function(xhr, errorType, error) {
            assert(false, 'Got error: ' + errorType + ' ' + error);
            return protocol.unregisterProtocol('atom-file-job');
          }
        });
      });
      it('returns RequestFileJob should send file from asar archive', function(done) {
        var handler, job, p;
        p = path.join(__dirname, 'fixtures', 'asar', 'a.asar', 'file1');
        job = new protocol.RequestFileJob(p);
        handler = remote.createFunctionWithReturnValue(job);
        protocol.registerProtocol('atom-file-job', handler);
        return $.ajax({
          url: 'atom-file-job://' + p,
          success: function(data) {
            var content;
            content = require('fs').readFileSync(p);
            assert.equal(data, String(content));
            protocol.unregisterProtocol('atom-file-job');
            return done();
          },
          error: function(xhr, errorType, error) {
            assert(false, 'Got error: ' + errorType + ' ' + error);
            return protocol.unregisterProtocol('atom-file-job');
          }
        });
      });
      return it('returns RequestFileJob should send file from asar archive with unpacked file', function(done) {
        var handler, job, p;
        p = path.join(__dirname, 'fixtures', 'asar', 'unpack.asar', 'a.txt');
        job = new protocol.RequestFileJob(p);
        handler = remote.createFunctionWithReturnValue(job);
        protocol.registerProtocol('atom-file-job', handler);
        return $.ajax({
          url: 'atom-file-job://' + p,
          success: function(response) {
            var buf, data;
            data = require('fs').readFileSync(p);
            assert.equal(response.length, data.length);
            buf = new Buffer(response.length);
            buf.write(response);
            assert(buf.equals(data));
            protocol.unregisterProtocol('atom-file-job');
            return done();
          },
          error: function(xhr, errorType, error) {
            assert(false, 'Got error: ' + errorType + ' ' + error);
            return protocol.unregisterProtocol('atom-file-job');
          }
        });
      });
    });
    describe('protocol.isHandledProtocol', function() {
      it('returns true if the file scheme can be handled', function(done) {
        return protocol.isHandledProtocol('file', function(result) {
          assert.equal(result, true);
          return done();
        });
      });
      it('returns true if the http scheme can be handled', function(done) {
        return protocol.isHandledProtocol('http', function(result) {
          assert.equal(result, true);
          return done();
        });
      });
      it('returns true if the https scheme can be handled', function(done) {
        return protocol.isHandledProtocol('https', function(result) {
          assert.equal(result, true);
          return done();
        });
      });
      return it('returns false if the atom scheme cannot be handled', function(done) {
        return protocol.isHandledProtocol('atom', function(result) {
          assert.equal(result, false);
          return done();
        });
      });
    });
    return describe('protocol.interceptProtocol', function() {
      it('throws error when scheme is not a registered one', function(done) {
        return protocol.interceptProtocol('test-intercept', (function() {}), function(error, scheme) {
          if (error != null) {
            assert.equal(scheme, 'test-intercept');
            return done();
          }
        });
      });
      it('throws error when scheme is a custom protocol', function(done) {
        protocol.once('unregistered', function(scheme) {
          assert.equal(scheme, 'atom');
          return done();
        });
        protocol.once('registered', function(scheme) {
          assert.equal(scheme, 'atom');
          return protocol.interceptProtocol('test-intercept', (function() {}), function(error, newScheme) {
            if (error != null) {
              assert.equal(newScheme, 'test-intercept');
              return protocol.unregisterProtocol(scheme);
            }
          });
        });
        return protocol.registerProtocol('atom', function() {});
      });
      it('returns original job when callback returns nothing', function(done) {
        var targetScheme;
        targetScheme = 'file';
        protocol.once('intercepted', function(scheme) {
          var free;
          assert.equal(scheme, targetScheme);
          free = function() {
            return protocol.uninterceptProtocol(targetScheme);
          };
          return $.ajax({
            url: targetScheme + "://" + __filename,
            success: function() {
              protocol.once('unintercepted', function(scheme) {
                assert.equal(scheme, targetScheme);
                return done();
              });
              return free();
            },
            error: function(xhr, errorType, error) {
              free();
              return assert(false, 'Got error: ' + errorType + ' ' + error);
            }
          });
        });
        return protocol.interceptProtocol(targetScheme, function(request) {
          var pathInUrl;
          if (process.platform === 'win32') {
            pathInUrl = path.normalize(request.url.substr(8));
            return assert.equal(pathInUrl.toLowerCase(), __filename.toLowerCase());
          } else {
            return assert.equal(request.url, targetScheme + "://" + __filename);
          }
        });
      });
      it('can override original protocol handler', function(done) {
        var handler;
        handler = remote.createFunctionWithReturnValue('valar morghulis');
        protocol.once('intercepted', function() {
          var free;
          free = function() {
            return protocol.uninterceptProtocol('file');
          };
          return $.ajax({
            url: 'file://fake-host',
            success: function(data) {
              protocol.once('unintercepted', function() {
                assert.equal(data, handler());
                return done();
              });
              return free();
            },
            error: function(xhr, errorType, error) {
              assert(false, 'Got error: ' + errorType + ' ' + error);
              return free();
            }
          });
        });
        return protocol.interceptProtocol('file', handler);
      });
      it('can override http protocol handler', function(done) {
        var handler;
        handler = remote.createFunctionWithReturnValue('valar morghulis');
        protocol.once('intercepted', function() {
          protocol.uninterceptProtocol('http');
          return done();
        });
        return protocol.interceptProtocol('http', handler);
      });
      it('can override https protocol handler', function(done) {
        var handler;
        handler = remote.createFunctionWithReturnValue('valar morghulis');
        protocol.once('intercepted', function() {
          protocol.uninterceptProtocol('https');
          return done();
        });
        return protocol.interceptProtocol('https', handler);
      });
      it('can override ws protocol handler', function(done) {
        var handler;
        handler = remote.createFunctionWithReturnValue('valar morghulis');
        protocol.once('intercepted', function() {
          protocol.uninterceptProtocol('ws');
          return done();
        });
        return protocol.interceptProtocol('ws', handler);
      });
      return it('can override wss protocol handler', function(done) {
        var handler;
        handler = remote.createFunctionWithReturnValue('valar morghulis');
        protocol.once('intercepted', function() {
          protocol.uninterceptProtocol('wss');
          return done();
        });
        return protocol.interceptProtocol('wss', handler);
      });
    });
  });

}).call(this);
