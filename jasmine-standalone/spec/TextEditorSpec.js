// Generated by CoffeeScript 1.9.3
(function() {
  var TextEditor, clipboard, fs, path, temp;

  fs = require('fs-plus');

  path = require('path');

  temp = require('temp');

  clipboard = require('../src/safe-clipboard');

  TextEditor = require('../src/text-editor');

  describe("TextEditor", function() {
    var buffer, convertToHardTabs, editor, lineLengths, ref;
    ref = [], buffer = ref[0], editor = ref[1], lineLengths = ref[2];
    convertToHardTabs = function(buffer) {
      return buffer.setText(buffer.getText().replace(/[ ]{2}/g, "\t"));
    };
    beforeEach(function() {
      waitsForPromise(function() {
        return atom.project.open('sample.js', {
          autoIndent: false
        }).then(function(o) {
          return editor = o;
        });
      });
      runs(function() {
        buffer = editor.buffer;
        return lineLengths = buffer.getLines().map(function(line) {
          return line.length;
        });
      });
      return waitsForPromise(function() {
        return atom.packages.activatePackage('language-javascript');
      });
    });
    describe("when the editor is deserialized", function() {
      it("returns undefined when the path cannot be read", function() {
        var editor1, pathToOpen;
        pathToOpen = path.join(temp.mkdirSync(), 'file.txt');
        editor1 = null;
        waitsForPromise(function() {
          return atom.project.open(pathToOpen).then(function(o) {
            return editor1 = o;
          });
        });
        return runs(function() {
          fs.mkdirSync(pathToOpen);
          return expect(editor1.testSerialization()).toBeUndefined();
        });
      });
      it("restores selections and folds based on markers in the buffer", function() {
        var editor2;
        editor.setSelectedBufferRange([[1, 2], [3, 4]]);
        editor.addSelectionForBufferRange([[5, 6], [7, 5]], {
          reversed: true
        });
        editor.foldBufferRow(4);
        expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();
        editor2 = editor.testSerialization();
        expect(editor2.id).toBe(editor.id);
        expect(editor2.getBuffer().getPath()).toBe(editor.getBuffer().getPath());
        expect(editor2.getSelectedBufferRanges()).toEqual([[[1, 2], [3, 4]], [[5, 6], [7, 5]]]);
        expect(editor2.getSelections()[1].isReversed()).toBeTruthy();
        expect(editor2.isFoldedAtBufferRow(4)).toBeTruthy();
        return editor2.destroy();
      });
      it("preserves the invisibles setting", function() {
        var editor2, previousInvisibles;
        atom.config.set('editor.showInvisibles', true);
        previousInvisibles = editor.tokenizedLineForScreenRow(0).invisibles;
        editor2 = editor.testSerialization();
        expect(previousInvisibles).toBeDefined();
        return expect(editor2.displayBuffer.tokenizedLineForScreenRow(0).invisibles).toEqual(previousInvisibles);
      });
      return it("updates invisibles if the settings have changed between serialization and deserialization", function() {
        var editor2, state;
        atom.config.set('editor.showInvisibles', true);
        state = editor.serialize();
        atom.config.set('editor.invisibles', {
          eol: '?'
        });
        editor2 = TextEditor.deserialize(state);
        return expect(editor.tokenizedLineForScreenRow(0).invisibles.eol).toBe('?');
      });
    });
    describe("when the editor is constructed with the largeFileMode option set to true", function() {
      return it("loads the editor but doesn't tokenize", function() {
        editor = null;
        waitsForPromise(function() {
          return atom.workspace.open('sample.js', {
            largeFileMode: true
          }).then(function(o) {
            return editor = o;
          });
        });
        return runs(function() {
          buffer = editor.getBuffer();
          expect(editor.tokenizedLineForScreenRow(0).text).toBe(buffer.lineForRow(0));
          expect(editor.tokenizedLineForScreenRow(0).tokens.length).toBe(1);
          expect(editor.tokenizedLineForScreenRow(1).tokens.length).toBe(2);
          expect(editor.tokenizedLineForScreenRow(12).text).toBe(buffer.lineForRow(12));
          expect(editor.tokenizedLineForScreenRow(0).tokens.length).toBe(1);
          expect(editor.getCursorScreenPosition()).toEqual([0, 0]);
          editor.insertText('hey"');
          expect(editor.tokenizedLineForScreenRow(0).tokens.length).toBe(1);
          return expect(editor.tokenizedLineForScreenRow(1).tokens.length).toBe(2);
        });
      });
    });
    describe(".copy()", function() {
      return it("returns a different edit session with the same initial state", function() {
        var editor2;
        editor.setSelectedBufferRange([[1, 2], [3, 4]]);
        editor.addSelectionForBufferRange([[5, 6], [7, 8]], {
          reversed: true
        });
        editor.foldBufferRow(4);
        expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();
        editor2 = editor.copy();
        expect(editor2.id).not.toBe(editor.id);
        expect(editor2.getSelectedBufferRanges()).toEqual(editor.getSelectedBufferRanges());
        expect(editor2.getSelections()[1].isReversed()).toBeTruthy();
        expect(editor2.isFoldedAtBufferRow(4)).toBeTruthy();
        editor2.getLastSelection().setBufferRange([[2, 1], [4, 3]]);
        expect(editor2.getSelectedBufferRanges()).not.toEqual(editor.getSelectedBufferRanges());
        editor2.unfoldBufferRow(4);
        return expect(editor2.isFoldedAtBufferRow(4)).not.toBe(editor.isFoldedAtBufferRow(4));
      });
    });
    describe("config defaults", function() {
      it("uses the `editor.tabLength`, `editor.softWrap`, and `editor.softTabs`, and `core.fileEncoding` config values", function() {
        var editor1, editor2;
        editor1 = null;
        editor2 = null;
        atom.config.set('editor.tabLength', 4);
        atom.config.set('editor.softWrap', true);
        atom.config.set('editor.softTabs', false);
        atom.config.set('core.fileEncoding', 'utf16le');
        waitsForPromise(function() {
          return atom.workspace.open('a').then(function(o) {
            return editor1 = o;
          });
        });
        runs(function() {
          expect(editor1.getTabLength()).toBe(4);
          expect(editor1.isSoftWrapped()).toBe(true);
          expect(editor1.getSoftTabs()).toBe(false);
          expect(editor1.getEncoding()).toBe('utf16le');
          atom.config.set('editor.tabLength', 8);
          atom.config.set('editor.softWrap', false);
          atom.config.set('editor.softTabs', true);
          return atom.config.set('core.fileEncoding', 'macroman');
        });
        waitsForPromise(function() {
          return atom.workspace.open('b').then(function(o) {
            return editor2 = o;
          });
        });
        return runs(function() {
          expect(editor2.getTabLength()).toBe(8);
          expect(editor2.isSoftWrapped()).toBe(false);
          expect(editor2.getSoftTabs()).toBe(true);
          return expect(editor2.getEncoding()).toBe('macroman');
        });
      });
      return it("uses scoped `core.fileEncoding` values", function() {
        var editor1, editor2;
        editor1 = null;
        editor2 = null;
        atom.config.set('core.fileEncoding', 'utf16le');
        atom.config.set('core.fileEncoding', 'macroman', {
          scopeSelector: '.js'
        });
        waitsForPromise(function() {
          return atom.workspace.open('a').then(function(o) {
            return editor1 = o;
          });
        });
        runs(function() {
          return expect(editor1.getEncoding()).toBe('utf16le');
        });
        waitsForPromise(function() {
          return atom.workspace.open('test.js').then(function(o) {
            return editor2 = o;
          });
        });
        return runs(function() {
          return expect(editor2.getEncoding()).toBe('macroman');
        });
      });
    });
    describe("title", function() {
      describe(")", function() {
        return it("uses the basename of the buffer's path as its title, or 'untitled' if the path is undefined", function() {
          expect(editor.getTitle().getTitle().toBe('sample.js');
          buffer.setPath(void 0);
          return expect(editor.getTitle()).toBe('untitled');
        });
      });
      describe(".getLongTitle()", function() {
        return it("appends the name of the containing directory to the basename of the file", function() {
          expect(editor.getLongTitle()).toBe('sample.js - fixtures');
          buffer.setPath(void 0);
          return expect(editor.getLongTitle()).toBe('untitled');
        });
      });
      return it("notifies ::onDidChangeTitle observers when the underlying buffer path changes", function() {
        var observed;
        observed = [];
        editor.onDidChangeTitle(function(title) {
          return observed.push(title);
        });
        buffer.setPath('/foo/bar/baz.txt');
        buffer.setPath(void 0);
        return expect(observed).toEqual(['baz.txt', 'untitled']);
      });
    });
    describe("path", function() {
      return it("notifies ::onDidChangePath observers when the underlying buffer path changes", function() {
        var observed;
        observed = [];
        editor.onDidChangePath(function(filePath) {
          return observed.push(filePath);
        });
        buffer.setPath(__filename);
        buffer.setPath(void 0);
        return expect(observed).toEqual([__filename, void 0]);
      });
    });
    describe("encoding", function() {
      return it("notifies ::onDidChangeEncoding observers when the editor encoding changes", function() {
        var observed;
        observed = [];
        editor.onDidChangeEncoding(function(encoding) {
          return observed.push(encoding);
        });
        editor.setEncoding('utf16le');
        editor.setEncoding('utf16le');
        editor.setEncoding('utf16be');
        editor.setEncoding();
        editor.setEncoding();
        return expect(observed).toEqual(['utf16le', 'utf16be', 'utf8']);
      });
    });
    describe("cursor", function() {
      describe(".getLastCursor()", function() {
        return it("returns the most recently created cursor", function() {
          var lastCursor;
          editor.addCursorAtScreenPosition([1, 0]);
          lastCursor = editor.addCursorAtScreenPosition([2, 0]);
          return expect(editor.getLastCursor()).toBe(lastCursor);
        });
      });
      describe("when the cursor moves", function() {
        it("clears a goal column established by vertical movement", function() {
          editor.setText('b');
          editor.setCursorBufferPosition([0, 0]);
          editor.insertNewline();
          editor.moveUp();
          editor.insertText('a');
          editor.moveDown();
          return expect(editor.getCursorBufferPosition()).toEqual([1, 1]);
        });
        return it("emits an event with the old position, new position, and the cursor that moved", function() {
          var cursorCallback, editorCallback, eventObject;
          cursorCallback = jasmine.createSpy('cursor-changed-position');
          editorCallback = jasmine.createSpy('editor-changed-cursor-position');
          editor.getLastCursor().onDidChangePosition(cursorCallback);
          editor.onDidChangeCursorPosition(editorCallback);
          editor.setCursorBufferPosition([2, 4]);
          expect(editorCallback).toHaveBeenCalled();
          expect(cursorCallback).toHaveBeenCalled();
          eventObject = editorCallback.mostRecentCall.args[0];
          expect(cursorCallback.mostRecentCall.args[0]).toEqual(eventObject);
          expect(eventObject.oldBufferPosition).toEqual([0, 0]);
          expect(eventObject.oldScreenPosition).toEqual([0, 0]);
          expect(eventObject.newBufferPosition).toEqual([2, 4]);
          expect(eventObject.newScreenPosition).toEqual([2, 4]);
          return expect(eventObject.cursor).toBe(editor.getLastCursor());
        });
      });
      describe(".setCursorScreenPosition(screenPosition)", function() {
        it("clears a goal column established by vertical movement", function() {
          editor.setCursorScreenPosition({
            row: 3,
            column: lineLengths[3]
          });
          editor.moveDown();
          expect(editor.getCursorScreenPosition().column).not.toBe(6);
          editor.setCursorScreenPosition([4, 6]);
          expect(editor.getCursorScreenPosition().column).toBe(6);
          editor.moveDown();
          return expect(editor.getCursorScreenPosition().column).toBe(6);
        });
        it("merges multiple cursors", function() {
          var cursor1, cursor2, ref1;
          editor.setCursorScreenPosition([0, 0]);
          editor.addCursorAtScreenPosition([0, 1]);
          ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
          editor.setCursorScreenPosition([4, 7]);
          expect(editor.getCursors().length).toBe(1);
          expect(editor.getCursors()).toEqual([cursor1]);
          return expect(editor.getCursorScreenPosition()).toEqual([4, 7]);
        });
        return describe("when soft-wrap is enabled and code is folded", function() {
          beforeEach(function() {
            editor.setSoftWrapped(true);
            editor.setEditorWidthInChars(50);
            return editor.createFold(2, 3);
          });
          return it("positions the cursor at the buffer position that corresponds to the given screen position", function() {
            editor.setCursorScreenPosition([9, 0]);
            return expect(editor.getCursorBufferPosition()).toEqual([8, 10]);
          });
        });
      });
      describe(".moveUp()", function() {
        it("moves the cursor up", function() {
          editor.setCursorScreenPosition([2, 2]);
          editor.moveUp();
          return expect(editor.getCursorScreenPosition()).toEqual([1, 2]);
        });
        it("retains the goal column across lines of differing length", function() {
          expect(lineLengths[6]).toBeGreaterThan(32);
          editor.setCursorScreenPosition({
            row: 6,
            column: 32
          });
          editor.moveUp();
          expect(editor.getCursorScreenPosition().column).toBe(lineLengths[5]);
          editor.moveUp();
          expect(editor.getCursorScreenPosition().column).toBe(lineLengths[4]);
          editor.moveUp();
          return expect(editor.getCursorScreenPosition().column).toBe(32);
        });
        describe("when the cursor is on the first line", function() {
          return it("moves the cursor to the beginning of the line, but retains the goal column", function() {
            editor.setCursorScreenPosition([0, 4]);
            editor.moveUp();
            expect(editor.getCursorScreenPosition()).toEqual([0, 0]);
            editor.moveDown();
            return expect(editor.getCursorScreenPosition()).toEqual([1, 4]);
          });
        });
        describe("when there is a selection", function() {
          beforeEach(function() {
            return editor.setSelectedBufferRange([[4, 9], [5, 10]]);
          });
          return it("moves above the selection", function() {
            var cursor;
            cursor = editor.getLastCursor();
            editor.moveUp();
            return expect(cursor.getBufferPosition()).toEqual([3, 9]);
          });
        });
        it("merges cursors when they overlap", function() {
          var cursor1, cursor2, ref1;
          editor.addCursorAtScreenPosition([1, 0]);
          ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
          editor.moveUp();
          expect(editor.getCursors()).toEqual([cursor1]);
          return expect(cursor1.getBufferPosition()).toEqual([0, 0]);
        });
        return describe("when the cursor was moved down from the beginning of an indented soft-wrapped line", function() {
          return it("moves to the beginning of the previous line", function() {
            editor.setSoftWrapped(true);
            editor.setEditorWidthInChars(50);
            editor.setCursorScreenPosition([3, 0]);
            editor.moveDown();
            editor.moveDown();
            editor.moveUp();
            return expect(editor.getCursorScreenPosition()).toEqual([4, 4]);
          });
        });
      });
      describe(".moveDown()", function() {
        it("moves the cursor down", function() {
          editor.setCursorScreenPosition([2, 2]);
          editor.moveDown();
          return expect(editor.getCursorScreenPosition()).toEqual([3, 2]);
        });
        it("retains the goal column across lines of differing length", function() {
          editor.setCursorScreenPosition({
            row: 3,
            column: lineLengths[3]
          });
          editor.moveDown();
          expect(editor.getCursorScreenPosition().column).toBe(lineLengths[4]);
          editor.moveDown();
          expect(editor.getCursorScreenPosition().column).toBe(lineLengths[5]);
          editor.moveDown();
          return expect(editor.getCursorScreenPosition().column).toBe(lineLengths[3]);
        });
        describe("when the cursor is on the last line", function() {
          it("moves the cursor to the end of line, but retains the goal column when moving back up", function() {
            var lastLine, lastLineIndex;
            lastLineIndex = buffer.getLines().length - 1;
            lastLine = buffer.lineForRow(lastLineIndex);
            expect(lastLine.length).toBeGreaterThan(0);
            editor.setCursorScreenPosition({
              row: lastLineIndex,
              column: editor.getTabLength()
            });
            editor.moveDown();
            expect(editor.getCursorScreenPosition()).toEqual({
              row: lastLineIndex,
              column: lastLine.length
            });
            editor.moveUp();
            return expect(editor.getCursorScreenPosition().column).toBe(editor.getTabLength());
          });
          return it("retains a goal column of 0 when moving back up", function() {
            var lastLine, lastLineIndex;
            lastLineIndex = buffer.getLines().length - 1;
            lastLine = buffer.lineForRow(lastLineIndex);
            expect(lastLine.length).toBeGreaterThan(0);
            editor.setCursorScreenPosition({
              row: lastLineIndex,
              column: 0
            });
            editor.moveDown();
            editor.moveUp();
            return expect(editor.getCursorScreenPosition().column).toBe(0);
          });
        });
        describe("when the cursor is at the beginning of an indented soft-wrapped line", function() {
          return it("moves to the beginning of the line's continuation on the next screen row", function() {
            editor.setSoftWrapped(true);
            editor.setEditorWidthInChars(50);
            editor.setCursorScreenPosition([3, 0]);
            editor.moveDown();
            return expect(editor.getCursorScreenPosition()).toEqual([4, 4]);
          });
        });
        describe("when there is a selection", function() {
          beforeEach(function() {
            return editor.setSelectedBufferRange([[4, 9], [5, 10]]);
          });
          return it("moves below the selection", function() {
            var cursor;
            cursor = editor.getLastCursor();
            editor.moveDown();
            return expect(cursor.getBufferPosition()).toEqual([6, 10]);
          });
        });
        return it("merges cursors when they overlap", function() {
          var cursor1, cursor2, ref1;
          editor.setCursorScreenPosition([12, 2]);
          editor.addCursorAtScreenPosition([11, 2]);
          ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
          editor.moveDown();
          expect(editor.getCursors()).toEqual([cursor1]);
          return expect(cursor1.getBufferPosition()).toEqual([12, 2]);
        });
      });
      describe(".moveLeft()", function() {
        it("moves the cursor by one column to the left", function() {
          editor.setCursorScreenPosition([1, 8]);
          editor.moveLeft();
          return expect(editor.getCursorScreenPosition()).toEqual([1, 7]);
        });
        it("moves the cursor by n columns to the left", function() {
          editor.setCursorScreenPosition([1, 8]);
          editor.moveLeft(4);
          return expect(editor.getCursorScreenPosition()).toEqual([1, 4]);
        });
        it("moves the cursor by two rows up when the columnCount is longer than an entire line", function() {
          editor.setCursorScreenPosition([2, 2]);
          editor.moveLeft(34);
          return expect(editor.getCursorScreenPosition()).toEqual([0, 29]);
        });
        it("moves the cursor to the beginning columnCount is longer than the position in the buffer", function() {
          editor.setCursorScreenPosition([1, 0]);
          editor.moveLeft(100);
          return expect(editor.getCursorScreenPosition()).toEqual([0, 0]);
        });
        describe("when the cursor is in the first column", function() {
          describe("when there is a previous line", function() {
            it("wraps to the end of the previous line", function() {
              editor.setCursorScreenPosition({
                row: 1,
                column: 0
              });
              editor.moveLeft();
              return expect(editor.getCursorScreenPosition()).toEqual({
                row: 0,
                column: buffer.lineForRow(0).length
              });
            });
            return it("moves the cursor by one row up and n columns to the left", function() {
              editor.setCursorScreenPosition([1, 0]);
              editor.moveLeft(4);
              return expect(editor.getCursorScreenPosition()).toEqual([0, 26]);
            });
          });
          describe("when the next line is empty", function() {
            return it("wraps to the beginning of the previous line", function() {
              editor.setCursorScreenPosition([11, 0]);
              editor.moveLeft();
              return expect(editor.getCursorScreenPosition()).toEqual([10, 0]);
            });
          });
          describe("when line is wrapped and follow previous line indentation", function() {
            beforeEach(function() {
              editor.setSoftWrapped(true);
              return editor.setEditorWidthInChars(50);
            });
            return it("wraps to the end of the previous line", function() {
              editor.setCursorScreenPosition([4, 4]);
              editor.moveLeft();
              return expect(editor.getCursorScreenPosition()).toEqual([3, 50]);
            });
          });
          return describe("when the cursor is on the first line", function() {
            it("remains in the same position (0,0)", function() {
              editor.setCursorScreenPosition({
                row: 0,
                column: 0
              });
              editor.moveLeft();
              return expect(editor.getCursorScreenPosition()).toEqual({
                row: 0,
                column: 0
              });
            });
            return it("remains in the same position (0,0) when columnCount is specified", function() {
              editor.setCursorScreenPosition([0, 0]);
              editor.moveLeft(4);
              return expect(editor.getCursorScreenPosition()).toEqual([0, 0]);
            });
          });
        });
        describe("when softTabs is enabled and the cursor is preceded by leading whitespace", function() {
          return it("skips tabLength worth of whitespace at a time", function() {
            editor.setCursorBufferPosition([5, 6]);
            editor.moveLeft();
            return expect(editor.getCursorBufferPosition()).toEqual([5, 4]);
          });
        });
        describe("when there is a selection", function() {
          beforeEach(function() {
            return editor.setSelectedBufferRange([[5, 22], [5, 27]]);
          });
          return it("moves to the left of the selection", function() {
            var cursor;
            cursor = editor.getLastCursor();
            editor.moveLeft();
            expect(cursor.getBufferPosition()).toEqual([5, 22]);
            editor.moveLeft();
            return expect(cursor.getBufferPosition()).toEqual([5, 21]);
          });
        });
        return it("merges cursors when they overlap", function() {
          var cursor1, cursor2, ref1;
          editor.setCursorScreenPosition([0, 0]);
          editor.addCursorAtScreenPosition([0, 1]);
          ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
          editor.moveLeft();
          expect(editor.getCursors()).toEqual([cursor1]);
          return expect(cursor1.getBufferPosition()).toEqual([0, 0]);
        });
      });
      describe(".moveRight()", function() {
        it("moves the cursor by one column to the right", function() {
          editor.setCursorScreenPosition([3, 3]);
          editor.moveRight();
          return expect(editor.getCursorScreenPosition()).toEqual([3, 4]);
        });
        it("moves the cursor by n columns to the right", function() {
          editor.setCursorScreenPosition([3, 7]);
          editor.moveRight(4);
          return expect(editor.getCursorScreenPosition()).toEqual([3, 11]);
        });
        it("moves the cursor by two rows down when the columnCount is longer than an entire line", function() {
          editor.setCursorScreenPosition([0, 29]);
          editor.moveRight(34);
          return expect(editor.getCursorScreenPosition()).toEqual([2, 2]);
        });
        it("moves the cursor to the end of the buffer when columnCount is longer than the number of characters following the cursor position", function() {
          editor.setCursorScreenPosition([11, 5]);
          editor.moveRight(100);
          return expect(editor.getCursorScreenPosition()).toEqual([12, 2]);
        });
        describe("when the cursor is on the last column of a line", function() {
          describe("when there is a subsequent line", function() {
            it("wraps to the beginning of the next line", function() {
              editor.setCursorScreenPosition([0, buffer.lineForRow(0).length]);
              editor.moveRight();
              return expect(editor.getCursorScreenPosition()).toEqual([1, 0]);
            });
            return it("moves the cursor by one row down and n columns to the right", function() {
              editor.setCursorScreenPosition([0, buffer.lineForRow(0).length]);
              editor.moveRight(4);
              return expect(editor.getCursorScreenPosition()).toEqual([1, 3]);
            });
          });
          describe("when the next line is empty", function() {
            return it("wraps to the beginning of the next line", function() {
              editor.setCursorScreenPosition([9, 4]);
              editor.moveRight();
              return expect(editor.getCursorScreenPosition()).toEqual([10, 0]);
            });
          });
          return describe("when the cursor is on the last line", function() {
            return it("remains in the same position", function() {
              var lastLine, lastLineIndex, lastPosition;
              lastLineIndex = buffer.getLines().length - 1;
              lastLine = buffer.lineForRow(lastLineIndex);
              expect(lastLine.length).toBeGreaterThan(0);
              lastPosition = {
                row: lastLineIndex,
                column: lastLine.length
              };
              editor.setCursorScreenPosition(lastPosition);
              editor.moveRight();
              return expect(editor.getCursorScreenPosition()).toEqual(lastPosition);
            });
          });
        });
        describe("when there is a selection", function() {
          beforeEach(function() {
            return editor.setSelectedBufferRange([[5, 22], [5, 27]]);
          });
          return it("moves to the left of the selection", function() {
            var cursor;
            cursor = editor.getLastCursor();
            editor.moveRight();
            expect(cursor.getBufferPosition()).toEqual([5, 27]);
            editor.moveRight();
            return expect(cursor.getBufferPosition()).toEqual([5, 28]);
          });
        });
        return it("merges cursors when they overlap", function() {
          var cursor1, cursor2, ref1;
          editor.setCursorScreenPosition([12, 2]);
          editor.addCursorAtScreenPosition([12, 1]);
          ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
          editor.moveRight();
          expect(editor.getCursors()).toEqual([cursor1]);
          return expect(cursor1.getBufferPosition()).toEqual([12, 2]);
        });
      });
      describe(".moveToTop()", function() {
        return it("moves the cursor to the top of the buffer", function() {
          editor.setCursorScreenPosition([11, 1]);
          editor.addCursorAtScreenPosition([12, 0]);
          editor.moveToTop();
          expect(editor.getCursors().length).toBe(1);
          return expect(editor.getCursorBufferPosition()).toEqual([0, 0]);
        });
      });
      describe(".moveToBottom()", function() {
        return it("moves the cusor to the bottom of the buffer", function() {
          editor.setCursorScreenPosition([0, 0]);
          editor.addCursorAtScreenPosition([1, 0]);
          editor.moveToBottom();
          expect(editor.getCursors().length).toBe(1);
          return expect(editor.getCursorBufferPosition()).toEqual([12, 2]);
        });
      });
      describe(".moveToBeginningOfScreenLine()", function() {
        describe("when soft wrap is on", function() {
          return it("moves cursor to the beginning of the screen line", function() {
            var cursor;
            editor.setSoftWrapped(true);
            editor.setEditorWidthInChars(10);
            editor.setCursorScreenPosition([1, 2]);
            editor.moveToBeginningOfScreenLine();
            cursor = editor.getLastCursor();
            return expect(cursor.getScreenPosition()).toEqual([1, 0]);
          });
        });
        return describe("when soft wrap is off", function() {
          return it("moves cursor to the beginning of the line", function() {
            var cursor1, cursor2, ref1;
            editor.setCursorScreenPosition([0, 5]);
            editor.addCursorAtScreenPosition([1, 7]);
            editor.moveToBeginningOfScreenLine();
            expect(editor.getCursors().length).toBe(2);
            ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
            expect(cursor1.getBufferPosition()).toEqual([0, 0]);
            return expect(cursor2.getBufferPosition()).toEqual([1, 0]);
          });
        });
      });
      describe(".moveToEndOfScreenLine()", function() {
        describe("when soft wrap is on", function() {
          return it("moves cursor to the beginning of the screen line", function() {
            var cursor;
            editor.setSoftWrapped(true);
            editor.setEditorWidthInChars(10);
            editor.setCursorScreenPosition([1, 2]);
            editor.moveToEndOfScreenLine();
            cursor = editor.getLastCursor();
            return expect(cursor.getScreenPosition()).toEqual([1, 9]);
          });
        });
        return describe("when soft wrap is off", function() {
          return it("moves cursor to the end of line", function() {
            var cursor1, cursor2, ref1;
            editor.setCursorScreenPosition([0, 0]);
            editor.addCursorAtScreenPosition([1, 0]);
            editor.moveToEndOfScreenLine();
            expect(editor.getCursors().length).toBe(2);
            ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
            expect(cursor1.getBufferPosition()).toEqual([0, 29]);
            return expect(cursor2.getBufferPosition()).toEqual([1, 30]);
          });
        });
      });
      describe(".moveToBeginningOfLine()", function() {
        return it("moves cursor to the beginning of the buffer line", function() {
          var cursor;
          editor.setSoftWrapped(true);
          editor.setEditorWidthInChars(10);
          editor.setCursorScreenPosition([1, 2]);
          editor.moveToBeginningOfLine();
          cursor = editor.getLastCursor();
          return expect(cursor.getScreenPosition()).toEqual([0, 0]);
        });
      });
      describe(".moveToEndOfLine()", function() {
        return it("moves cursor to the end of the buffer line", function() {
          var cursor;
          editor.setSoftWrapped(true);
          editor.setEditorWidthInChars(10);
          editor.setCursorScreenPosition([0, 2]);
          editor.moveToEndOfLine();
          cursor = editor.getLastCursor();
          return expect(cursor.getScreenPosition()).toEqual([3, 4]);
        });
      });
      describe(".moveToFirstCharacterOfLine()", function() {
        describe("when soft wrap is on", function() {
          return it("moves to the first character of the current screen line or the beginning of the screen line if it's already on the first character", function() {
            var cursor1, cursor2, ref1;
            editor.setSoftWrapped(true);
            editor.setEditorWidthInChars(10);
            editor.setCursorScreenPosition([2, 5]);
            editor.addCursorAtScreenPosition([8, 7]);
            editor.moveToFirstCharacterOfLine();
            ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
            expect(cursor1.getScreenPosition()).toEqual([2, 0]);
            expect(cursor2.getScreenPosition()).toEqual([8, 2]);
            editor.moveToFirstCharacterOfLine();
            expect(cursor1.getScreenPosition()).toEqual([2, 0]);
            return expect(cursor2.getScreenPosition()).toEqual([8, 2]);
          });
        });
        return describe("when soft wrap is off", function() {
          it("moves to the first character of the current line or the beginning of the line if it's already on the first character", function() {
            var cursor1, cursor2, ref1;
            editor.setCursorScreenPosition([0, 5]);
            editor.addCursorAtScreenPosition([1, 7]);
            editor.moveToFirstCharacterOfLine();
            ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
            expect(cursor1.getBufferPosition()).toEqual([0, 0]);
            expect(cursor2.getBufferPosition()).toEqual([1, 2]);
            editor.moveToFirstCharacterOfLine();
            expect(cursor1.getBufferPosition()).toEqual([0, 0]);
            return expect(cursor2.getBufferPosition()).toEqual([1, 0]);
          });
          it("moves to the beginning of the line if it only contains whitespace ", function() {
            var cursor;
            editor.setText("first\n    \nthird");
            editor.setCursorScreenPosition([1, 2]);
            editor.moveToFirstCharacterOfLine();
            cursor = editor.getLastCursor();
            return expect(cursor.getBufferPosition()).toEqual([1, 0]);
          });
          describe("when invisible characters are enabled with soft tabs", function() {
            return it("moves to the first character of the current line without being confused by the invisible characters", function() {
              atom.config.set('editor.showInvisibles', true);
              editor.setCursorScreenPosition([1, 7]);
              editor.moveToFirstCharacterOfLine();
              expect(editor.getCursorBufferPosition()).toEqual([1, 2]);
              editor.moveToFirstCharacterOfLine();
              return expect(editor.getCursorBufferPosition()).toEqual([1, 0]);
            });
          });
          return describe("when invisible characters are enabled with hard tabs", function() {
            return it("moves to the first character of the current line without being confused by the invisible characters", function() {
              atom.config.set('editor.showInvisibles', true);
              buffer.setTextInRange([[1, 0], [1, Infinity]], '\t\t\ta', {
                normalizeLineEndings: false
              });
              editor.setCursorScreenPosition([1, 7]);
              editor.moveToFirstCharacterOfLine();
              expect(editor.getCursorBufferPosition()).toEqual([1, 3]);
              editor.moveToFirstCharacterOfLine();
              return expect(editor.getCursorBufferPosition()).toEqual([1, 0]);
            });
          });
        });
      });
      describe(".moveToBeginningOfWord()", function() {
        it("moves the cursor to the beginning of the word", function() {
          var cursor1, cursor2, cursor3, ref1;
          editor.setCursorBufferPosition([0, 8]);
          editor.addCursorAtBufferPosition([1, 12]);
          editor.addCursorAtBufferPosition([3, 0]);
          ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1], cursor3 = ref1[2];
          editor.moveToBeginningOfWord();
          expect(cursor1.getBufferPosition()).toEqual([0, 4]);
          expect(cursor2.getBufferPosition()).toEqual([1, 11]);
          return expect(cursor3.getBufferPosition()).toEqual([2, 39]);
        });
        it("does not fail at position [0, 0]", function() {
          editor.setCursorBufferPosition([0, 0]);
          return editor.moveToBeginningOfWord();
        });
        it("treats lines with only whitespace as a word", function() {
          editor.setCursorBufferPosition([11, 0]);
          editor.moveToBeginningOfWord();
          return expect(editor.getCursorBufferPosition()).toEqual([10, 0]);
        });
        return it("works when the current line is blank", function() {
          editor.setCursorBufferPosition([10, 0]);
          editor.moveToBeginningOfWord();
          return expect(editor.getCursorBufferPosition()).toEqual([9, 2]);
        });
      });
      describe(".moveToPreviousWordBoundary()", function() {
        return it("moves the cursor to the previous word boundary", function() {
          var cursor1, cursor2, cursor3, cursor4, ref1;
          editor.setCursorBufferPosition([0, 8]);
          editor.addCursorAtBufferPosition([2, 0]);
          editor.addCursorAtBufferPosition([2, 4]);
          editor.addCursorAtBufferPosition([3, 14]);
          ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1], cursor3 = ref1[2], cursor4 = ref1[3];
          editor.moveToPreviousWordBoundary();
          expect(cursor1.getBufferPosition()).toEqual([0, 4]);
          expect(cursor2.getBufferPosition()).toEqual([1, 30]);
          expect(cursor3.getBufferPosition()).toEqual([2, 0]);
          return expect(cursor4.getBufferPosition()).toEqual([3, 13]);
        });
      });
      describe(".moveToNextWordBoundary()", function() {
        return it("moves the cursor to the previous word boundary", function() {
          var cursor1, cursor2, cursor3, cursor4, ref1;
          editor.setCursorBufferPosition([0, 8]);
          editor.addCursorAtBufferPosition([2, 40]);
          editor.addCursorAtBufferPosition([3, 0]);
          editor.addCursorAtBufferPosition([3, 30]);
          ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1], cursor3 = ref1[2], cursor4 = ref1[3];
          editor.moveToNextWordBoundary();
          expect(cursor1.getBufferPosition()).toEqual([0, 13]);
          expect(cursor2.getBufferPosition()).toEqual([3, 0]);
          expect(cursor3.getBufferPosition()).toEqual([3, 4]);
          return expect(cursor4.getBufferPosition()).toEqual([3, 31]);
        });
      });
      describe(".moveToEndOfWord()", function() {
        it("moves the cursor to the end of the word", function() {
          var cursor1, cursor2, cursor3, ref1;
          editor.setCursorBufferPosition([0, 6]);
          editor.addCursorAtBufferPosition([1, 10]);
          editor.addCursorAtBufferPosition([2, 40]);
          ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1], cursor3 = ref1[2];
          editor.moveToEndOfWord();
          expect(cursor1.getBufferPosition()).toEqual([0, 13]);
          expect(cursor2.getBufferPosition()).toEqual([1, 12]);
          return expect(cursor3.getBufferPosition()).toEqual([3, 7]);
        });
        it("does not blow up when there is no next word", function() {
          var endPosition;
          editor.setCursorBufferPosition([Infinity, Infinity]);
          endPosition = editor.getCursorBufferPosition();
          editor.moveToEndOfWord();
          return expect(editor.getCursorBufferPosition()).toEqual(endPosition);
        });
        it("treats lines with only whitespace as a word", function() {
          editor.setCursorBufferPosition([9, 4]);
          editor.moveToEndOfWord();
          return expect(editor.getCursorBufferPosition()).toEqual([10, 0]);
        });
        return it("works when the current line is blank", function() {
          editor.setCursorBufferPosition([10, 0]);
          editor.moveToEndOfWord();
          return expect(editor.getCursorBufferPosition()).toEqual([11, 8]);
        });
      });
      describe(".moveToBeginningOfNextWord()", function() {
        it("moves the cursor before the first character of the next word", function() {
          var cursor, cursor1, cursor2, cursor3, ref1;
          editor.setCursorBufferPosition([0, 6]);
          editor.addCursorAtBufferPosition([1, 11]);
          editor.addCursorAtBufferPosition([2, 0]);
          ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1], cursor3 = ref1[2];
          editor.moveToBeginningOfNextWord();
          expect(cursor1.getBufferPosition()).toEqual([0, 14]);
          expect(cursor2.getBufferPosition()).toEqual([1, 13]);
          expect(cursor3.getBufferPosition()).toEqual([2, 4]);
          editor.setText("ab cde- ");
          editor.setCursorBufferPosition([0, 2]);
          cursor = editor.getLastCursor();
          editor.moveToBeginningOfNextWord();
          return expect(cursor.getBufferPosition()).toEqual([0, 3]);
        });
        it("does not blow up when there is no next word", function() {
          var endPosition;
          editor.setCursorBufferPosition([Infinity, Infinity]);
          endPosition = editor.getCursorBufferPosition();
          editor.moveToBeginningOfNextWord();
          return expect(editor.getCursorBufferPosition()).toEqual(endPosition);
        });
        it("treats lines with only whitespace as a word", function() {
          editor.setCursorBufferPosition([9, 4]);
          editor.moveToBeginningOfNextWord();
          return expect(editor.getCursorBufferPosition()).toEqual([10, 0]);
        });
        return it("works when the current line is blank", function() {
          editor.setCursorBufferPosition([10, 0]);
          editor.moveToBeginningOfNextWord();
          return expect(editor.getCursorBufferPosition()).toEqual([11, 9]);
        });
      });
      describe(".moveToBeginningOfNextParagraph()", function() {
        return it("moves the cursor before the first line of the next paragraph", function() {
          editor.setCursorBufferPosition([0, 6]);
          editor.foldBufferRow(4);
          editor.moveToBeginningOfNextParagraph();
          expect(editor.getCursorBufferPosition()).toEqual([10, 0]);
          editor.setText("");
          editor.setCursorBufferPosition([0, 0]);
          editor.moveToBeginningOfNextParagraph();
          return expect(editor.getCursorBufferPosition()).toEqual([0, 0]);
        });
      });
      describe(".moveToBeginningOfPreviousParagraph()", function() {
        return it("moves the cursor before the first line of the pevious paragraph", function() {
          editor.setCursorBufferPosition([10, 0]);
          editor.foldBufferRow(4);
          editor.moveToBeginningOfPreviousParagraph();
          expect(editor.getCursorBufferPosition()).toEqual([0, 0]);
          editor.setText("");
          editor.setCursorBufferPosition([0, 0]);
          editor.moveToBeginningOfPreviousParagraph();
          return expect(editor.getCursorBufferPosition()).toEqual([0, 0]);
        });
      });
      describe(".getCurrentParagraphBufferRange()", function() {
        return it("returns the buffer range of the current paragraph, delimited by blank lines or the beginning / end of the file", function() {
          buffer.setText("  I am the first paragraph,\nbordered by the beginning of\nthe file\n" + '   ' + "\n\n  I am the second paragraph\nwith blank lines above and below\nme.\n\nI am the last paragraph,\nbordered by the end of the file.");
          editor.setCursorBufferPosition([1, 7]);
          expect(editor.getCurrentParagraphBufferRange()).toEqual([[0, 0], [2, 8]]);
          editor.setCursorBufferPosition([7, 1]);
          expect(editor.getCurrentParagraphBufferRange()).toEqual([[5, 0], [7, 3]]);
          editor.setCursorBufferPosition([9, 10]);
          expect(editor.getCurrentParagraphBufferRange()).toEqual([[9, 0], [10, 32]]);
          editor.setCursorBufferPosition([3, 1]);
          return expect(editor.getCurrentParagraphBufferRange()).toBeUndefined();
        });
      });
      describe("getCursorAtScreenPosition(screenPosition)", function() {
        return it("returns the cursor at the given screenPosition", function() {
          var cursor1, cursor2;
          cursor1 = editor.addCursorAtScreenPosition([0, 2]);
          cursor2 = editor.getCursorAtScreenPosition(cursor1.getScreenPosition());
          return expect(cursor2).toBe(cursor1);
        });
      });
      describe("::getCursorScreenPositions()", function() {
        return it("returns the cursor positions in the order they were added", function() {
          var cursor1, cursor2;
          editor.foldBufferRow(4);
          cursor1 = editor.addCursorAtBufferPosition([8, 5]);
          cursor2 = editor.addCursorAtBufferPosition([3, 5]);
          return expect(editor.getCursorScreenPositions()).toEqual([[0, 0], [5, 5], [3, 5]]);
        });
      });
      describe("::getCursorsOrderedByBufferPosition()", function() {
        return it("returns all cursors ordered by buffer positions", function() {
          var cursor1, cursor2, originalCursor;
          originalCursor = editor.getLastCursor();
          cursor1 = editor.addCursorAtBufferPosition([8, 5]);
          cursor2 = editor.addCursorAtBufferPosition([4, 5]);
          return expect(editor.getCursorsOrderedByBufferPosition()).toEqual([originalCursor, cursor2, cursor1]);
        });
      });
      describe("addCursorAtScreenPosition(screenPosition)", function() {
        return describe("when a cursor already exists at the position", function() {
          return it("returns the existing cursor", function() {
            var cursor1, cursor2;
            cursor1 = editor.addCursorAtScreenPosition([0, 2]);
            cursor2 = editor.addCursorAtScreenPosition([0, 2]);
            return expect(cursor2).toBe(cursor1);
          });
        });
      });
      describe("addCursorAtBufferPosition(bufferPosition)", function() {
        return describe("when a cursor already exists at the position", function() {
          return it("returns the existing cursor", function() {
            var cursor1, cursor2;
            cursor1 = editor.addCursorAtBufferPosition([1, 4]);
            cursor2 = editor.addCursorAtBufferPosition([1, 4]);
            return expect(cursor2.marker).toBe(cursor1.marker);
          });
        });
      });
      describe("autoscroll", function() {
        beforeEach(function() {
          editor.setVerticalScrollMargin(2);
          editor.setHorizontalScrollMargin(2);
          editor.setLineHeightInPixels(10);
          editor.setDefaultCharWidth(10);
          editor.setHorizontalScrollbarHeight(0);
          editor.setHeight(5.5 * 10);
          return editor.setWidth(5.5 * 10);
        });
        it("scrolls down when the last cursor gets closer than ::verticalScrollMargin to the bottom of the editor", function() {
          expect(editor.getScrollTop()).toBe(0);
          expect(editor.getScrollBottom()).toBe(5.5 * 10);
          editor.setCursorScreenPosition([2, 0]);
          expect(editor.getScrollBottom()).toBe(5.5 * 10);
          editor.moveDown();
          expect(editor.getScrollBottom()).toBe(6 * 10);
          editor.moveDown();
          return expect(editor.getScrollBottom()).toBe(7 * 10);
        });
        it("scrolls up when the last cursor gets closer than ::verticalScrollMargin to the top of the editor", function() {
          editor.setCursorScreenPosition([11, 0]);
          editor.setScrollBottom(editor.getScrollHeight());
          editor.moveUp();
          expect(editor.getScrollBottom()).toBe(editor.getScrollHeight());
          editor.moveUp();
          expect(editor.getScrollTop()).toBe(7 * 10);
          editor.moveUp();
          return expect(editor.getScrollTop()).toBe(6 * 10);
        });
        it("scrolls right when the last cursor gets closer than ::horizontalScrollMargin to the right of the editor", function() {
          expect(editor.getScrollLeft()).toBe(0);
          expect(editor.getScrollRight()).toBe(5.5 * 10);
          editor.setCursorScreenPosition([0, 2]);
          expect(editor.getScrollRight()).toBe(5.5 * 10);
          editor.moveRight();
          expect(editor.getScrollRight()).toBe(6 * 10);
          editor.moveRight();
          return expect(editor.getScrollRight()).toBe(7 * 10);
        });
        it("scrolls left when the last cursor gets closer than ::horizontalScrollMargin to the left of the editor", function() {
          editor.setScrollRight(editor.getScrollWidth());
          expect(editor.getScrollRight()).toBe(editor.getScrollWidth());
          editor.setCursorScreenPosition([6, 62], {
            autoscroll: false
          });
          editor.moveLeft();
          expect(editor.getScrollLeft()).toBe(59 * 10);
          editor.moveLeft();
          return expect(editor.getScrollLeft()).toBe(58 * 10);
        });
        it("scrolls down when inserting lines makes the document longer than the editor's height", function() {
          editor.setCursorScreenPosition([13, Infinity]);
          editor.insertNewline();
          expect(editor.getScrollBottom()).toBe(14 * 10);
          editor.insertNewline();
          return expect(editor.getScrollBottom()).toBe(15 * 10);
        });
        it("autoscrolls to the cursor when it moves due to undo", function() {
          editor.insertText('abc');
          editor.setScrollTop(Infinity);
          editor.undo();
          return expect(editor.getScrollTop()).toBe(0);
        });
        it("doesn't scroll when the cursor moves into the visible area", function() {
          editor.setCursorBufferPosition([0, 0]);
          editor.setScrollTop(40);
          expect(editor.getVisibleRowRange()).toEqual([4, 9]);
          editor.setCursorBufferPosition([6, 0]);
          return expect(editor.getScrollTop()).toBe(40);
        });
        return it("honors the autoscroll option on cursor and selection manipulation methods", function() {
          expect(editor.getScrollTop()).toBe(0);
          editor.addCursorAtScreenPosition([11, 11], {
            autoscroll: false
          });
          expect(editor.getScrollTop()).toBe(0);
          editor.addCursorAtBufferPosition([11, 11], {
            autoscroll: false
          });
          expect(editor.getScrollTop()).toBe(0);
          editor.setCursorScreenPosition([11, 11], {
            autoscroll: false
          });
          expect(editor.getScrollTop()).toBe(0);
          editor.setCursorBufferPosition([11, 11], {
            autoscroll: false
          });
          expect(editor.getScrollTop()).toBe(0);
          editor.addSelectionForBufferRange([[11, 11], [11, 11]], {
            autoscroll: false
          });
          expect(editor.getScrollTop()).toBe(0);
          editor.addSelectionForScreenRange([[11, 11], [11, 12]], {
            autoscroll: false
          });
          expect(editor.getScrollTop()).toBe(0);
          editor.setSelectedBufferRange([[11, 0], [11, 1]], {
            autoscroll: false
          });
          expect(editor.getScrollTop()).toBe(0);
          editor.setSelectedScreenRange([[11, 0], [11, 6]], {
            autoscroll: false
          });
          expect(editor.getScrollTop()).toBe(0);
          editor.clearSelections({
            autoscroll: false
          });
          expect(editor.getScrollTop()).toBe(0);
          editor.addSelectionForScreenRange([[0, 0], [0, 4]]);
          editor.getCursors()[0].setScreenPosition([11, 11], {
            autoscroll: true
          });
          expect(editor.getScrollTop()).toBeGreaterThan(0);
          editor.getCursors()[0].setBufferPosition([0, 0], {
            autoscroll: true
          });
          expect(editor.getScrollTop()).toBe(0);
          editor.getSelections()[0].setScreenRange([[11, 0], [11, 4]], {
            autoscroll: true
          });
          expect(editor.getScrollTop()).toBeGreaterThan(0);
          editor.getSelections()[0].setBufferRange([[0, 0], [0, 4]], {
            autoscroll: true
          });
          return expect(editor.getScrollTop()).toBe(0);
        });
      });
      return describe('.logCursorScope()', function() {
        beforeEach(function() {
          return spyOn(atom.notifications, 'addInfo');
        });
        return it('opens a notification', function() {
          editor.logCursorScope();
          return expect(atom.notifications.addInfo).toHaveBeenCalled();
        });
      });
    });
    describe("selection", function() {
      var selection;
      selection = null;
      beforeEach(function() {
        return selection = editor.getLastSelection();
      });
      describe("when the selection range changes", function() {
        return it("emits an event with the old range, new range, and the selection that moved", function() {
          var eventObject, rangeChangedHandler;
          editor.setSelectedBufferRange([[3, 0], [4, 5]]);
          editor.onDidChangeSelectionRange(rangeChangedHandler = jasmine.createSpy());
          editor.selectToBufferPosition([6, 2]);
          expect(rangeChangedHandler).toHaveBeenCalled();
          eventObject = rangeChangedHandler.mostRecentCall.args[0];
          expect(eventObject.oldBufferRange).toEqual([[3, 0], [4, 5]]);
          expect(eventObject.oldScreenRange).toEqual([[3, 0], [4, 5]]);
          expect(eventObject.newBufferRange).toEqual([[3, 0], [6, 2]]);
          expect(eventObject.newScreenRange).toEqual([[3, 0], [6, 2]]);
          return expect(eventObject.selection).toBe(selection);
        });
      });
      describe(".selectUp/Down/Left/Right()", function() {
        it("expands each selection to its cursor's new location", function() {
          var ref1, selection1, selection2;
          editor.setSelectedBufferRanges([[[0, 9], [0, 13]], [[3, 16], [3, 21]]]);
          ref1 = editor.getSelections(), selection1 = ref1[0], selection2 = ref1[1];
          editor.selectRight();
          expect(selection1.getBufferRange()).toEqual([[0, 9], [0, 14]]);
          expect(selection2.getBufferRange()).toEqual([[3, 16], [3, 22]]);
          editor.selectLeft();
          editor.selectLeft();
          expect(selection1.getBufferRange()).toEqual([[0, 9], [0, 12]]);
          expect(selection2.getBufferRange()).toEqual([[3, 16], [3, 20]]);
          editor.selectDown();
          expect(selection1.getBufferRange()).toEqual([[0, 9], [1, 12]]);
          expect(selection2.getBufferRange()).toEqual([[3, 16], [4, 20]]);
          editor.selectUp();
          expect(selection1.getBufferRange()).toEqual([[0, 9], [0, 12]]);
          return expect(selection2.getBufferRange()).toEqual([[3, 16], [3, 20]]);
        });
        it("merges selections when they intersect when moving down", function() {
          var ref1, selection1, selection2, selection3;
          editor.setSelectedBufferRanges([[[0, 9], [0, 13]], [[1, 10], [1, 20]], [[2, 15], [3, 25]]]);
          ref1 = editor.getSelections(), selection1 = ref1[0], selection2 = ref1[1], selection3 = ref1[2];
          editor.selectDown();
          expect(editor.getSelections()).toEqual([selection1]);
          expect(selection1.getScreenRange()).toEqual([[0, 9], [4, 25]]);
          return expect(selection1.isReversed()).toBeFalsy();
        });
        it("merges selections when they intersect when moving up", function() {
          var ref1, selection1, selection2;
          editor.setSelectedBufferRanges([[[0, 9], [0, 13]], [[1, 10], [1, 20]]], {
            reversed: true
          });
          ref1 = editor.getSelections(), selection1 = ref1[0], selection2 = ref1[1];
          editor.selectUp();
          expect(editor.getSelections().length).toBe(1);
          expect(editor.getSelections()).toEqual([selection1]);
          expect(selection1.getScreenRange()).toEqual([[0, 0], [1, 20]]);
          return expect(selection1.isReversed()).toBeTruthy();
        });
        it("merges selections when they intersect when moving left", function() {
          var ref1, selection1, selection2;
          editor.setSelectedBufferRanges([[[0, 9], [0, 13]], [[0, 13], [1, 20]]], {
            reversed: true
          });
          ref1 = editor.getSelections(), selection1 = ref1[0], selection2 = ref1[1];
          editor.selectLeft();
          expect(editor.getSelections()).toEqual([selection1]);
          expect(selection1.getScreenRange()).toEqual([[0, 8], [1, 20]]);
          return expect(selection1.isReversed()).toBeTruthy();
        });
        it("merges selections when they intersect when moving right", function() {
          var ref1, selection1, selection2;
          editor.setSelectedBufferRanges([[[0, 9], [0, 14]], [[0, 14], [1, 20]]]);
          ref1 = editor.getSelections(), selection1 = ref1[0], selection2 = ref1[1];
          editor.selectRight();
          expect(editor.getSelections()).toEqual([selection1]);
          expect(selection1.getScreenRange()).toEqual([[0, 9], [1, 21]]);
          return expect(selection1.isReversed()).toBeFalsy();
        });
        return describe("when counts are passed into the selection functions", function() {
          return it("expands each selection to its cursor's new location", function() {
            var ref1, selection1, selection2;
            editor.setSelectedBufferRanges([[[0, 9], [0, 13]], [[3, 16], [3, 21]]]);
            ref1 = editor.getSelections(), selection1 = ref1[0], selection2 = ref1[1];
            editor.selectRight(2);
            expect(selection1.getBufferRange()).toEqual([[0, 9], [0, 15]]);
            expect(selection2.getBufferRange()).toEqual([[3, 16], [3, 23]]);
            editor.selectLeft(3);
            expect(selection1.getBufferRange()).toEqual([[0, 9], [0, 12]]);
            expect(selection2.getBufferRange()).toEqual([[3, 16], [3, 20]]);
            editor.selectDown(3);
            expect(selection1.getBufferRange()).toEqual([[0, 9], [3, 12]]);
            expect(selection2.getBufferRange()).toEqual([[3, 16], [6, 20]]);
            editor.selectUp(2);
            expect(selection1.getBufferRange()).toEqual([[0, 9], [1, 12]]);
            return expect(selection2.getBufferRange()).toEqual([[3, 16], [4, 20]]);
          });
        });
      });
      describe(".selectToBufferPosition(bufferPosition)", function() {
        return it("expands the last selection to the given position", function() {
          var selection1, selection2, selections;
          editor.setSelectedBufferRange([[3, 0], [4, 5]]);
          editor.addCursorAtBufferPosition([5, 6]);
          editor.selectToBufferPosition([6, 2]);
          selections = editor.getSelections();
          expect(selections.length).toBe(2);
          selection1 = selections[0], selection2 = selections[1];
          expect(selection1.getBufferRange()).toEqual([[3, 0], [4, 5]]);
          return expect(selection2.getBufferRange()).toEqual([[5, 6], [6, 2]]);
        });
      });
      describe(".selectToScreenPosition(screenPosition)", function() {
        it("expands the last selection to the given position", function() {
          var selection1, selection2, selections;
          editor.setSelectedBufferRange([[3, 0], [4, 5]]);
          editor.addCursorAtScreenPosition([5, 6]);
          editor.selectToScreenPosition([6, 2]);
          selections = editor.getSelections();
          expect(selections.length).toBe(2);
          selection1 = selections[0], selection2 = selections[1];
          expect(selection1.getScreenRange()).toEqual([[3, 0], [4, 5]]);
          return expect(selection2.getScreenRange()).toEqual([[5, 6], [6, 2]]);
        });
        return describe("when selecting with an initial screen range", function() {
          return it("switches the direction of the selection when selecting to positions before/after the start of the initial range", function() {
            editor.setCursorScreenPosition([5, 10]);
            editor.selectWordsContainingCursors();
            editor.selectToScreenPosition([3, 0]);
            expect(editor.getLastSelection().isReversed()).toBe(true);
            editor.selectToScreenPosition([9, 0]);
            return expect(editor.getLastSelection().isReversed()).toBe(false);
          });
        });
      });
      describe(".selectToBeginningOfNextParagraph()", function() {
        return it("selects from the cursor to first line of the next paragraph", function() {
          var selections;
          editor.setSelectedBufferRange([[3, 0], [4, 5]]);
          editor.addCursorAtScreenPosition([5, 6]);
          editor.selectToScreenPosition([6, 2]);
          editor.selectToBeginningOfNextParagraph();
          selections = editor.getSelections();
          expect(selections.length).toBe(1);
          return expect(selections[0].getScreenRange()).toEqual([[3, 0], [10, 0]]);
        });
      });
      describe(".selectToBeginningOfPreviousParagraph()", function() {
        it("selects from the cursor to the first line of the pevious paragraph", function() {
          var selections;
          editor.setSelectedBufferRange([[3, 0], [4, 5]]);
          editor.addCursorAtScreenPosition([5, 6]);
          editor.selectToScreenPosition([6, 2]);
          editor.selectToBeginningOfPreviousParagraph();
          selections = editor.getSelections();
          expect(selections.length).toBe(1);
          return expect(selections[0].getScreenRange()).toEqual([[0, 0], [5, 6]]);
        });
        return it("merges selections if they intersect, maintaining the directionality of the last selection", function() {
          var selection1, selections;
          editor.setCursorScreenPosition([4, 10]);
          editor.selectToScreenPosition([5, 27]);
          editor.addCursorAtScreenPosition([3, 10]);
          editor.selectToScreenPosition([6, 27]);
          selections = editor.getSelections();
          expect(selections.length).toBe(1);
          selection1 = selections[0];
          expect(selection1.getScreenRange()).toEqual([[3, 10], [6, 27]]);
          expect(selection1.isReversed()).toBeFalsy();
          editor.addCursorAtScreenPosition([7, 4]);
          editor.selectToScreenPosition([4, 11]);
          selections = editor.getSelections();
          expect(selections.length).toBe(1);
          selection1 = selections[0];
          expect(selection1.getScreenRange()).toEqual([[3, 10], [7, 4]]);
          return expect(selection1.isReversed()).toBeTruthy();
        });
      });
      describe(".selectToTop()", function() {
        return it("selects text from cusor position to the top of the buffer", function() {
          editor.setCursorScreenPosition([11, 2]);
          editor.addCursorAtScreenPosition([10, 0]);
          editor.selectToTop();
          expect(editor.getCursors().length).toBe(1);
          expect(editor.getCursorBufferPosition()).toEqual([0, 0]);
          expect(editor.getLastSelection().getBufferRange()).toEqual([[0, 0], [11, 2]]);
          return expect(editor.getLastSelection().isReversed()).toBeTruthy();
        });
      });
      describe(".selectToBottom()", function() {
        return it("selects text from cusor position to the bottom of the buffer", function() {
          editor.setCursorScreenPosition([10, 0]);
          editor.addCursorAtScreenPosition([9, 3]);
          editor.selectToBottom();
          expect(editor.getCursors().length).toBe(1);
          expect(editor.getCursorBufferPosition()).toEqual([12, 2]);
          expect(editor.getLastSelection().getBufferRange()).toEqual([[9, 3], [12, 2]]);
          return expect(editor.getLastSelection().isReversed()).toBeFalsy();
        });
      });
      describe(".selectAll()", function() {
        return it("selects the entire buffer", function() {
          editor.selectAll();
          return expect(editor.getLastSelection().getBufferRange()).toEqual(buffer.getRange());
        });
      });
      describe(".selectToBeginningOfLine()", function() {
        return it("selects text from cusor position to beginning of line", function() {
          var cursor1, cursor2, ref1, ref2, selection1, selection2;
          editor.setCursorScreenPosition([12, 2]);
          editor.addCursorAtScreenPosition([11, 3]);
          editor.selectToBeginningOfLine();
          expect(editor.getCursors().length).toBe(2);
          ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
          expect(cursor1.getBufferPosition()).toEqual([12, 0]);
          expect(cursor2.getBufferPosition()).toEqual([11, 0]);
          expect(editor.getSelections().length).toBe(2);
          ref2 = editor.getSelections(), selection1 = ref2[0], selection2 = ref2[1];
          expect(selection1.getBufferRange()).toEqual([[12, 0], [12, 2]]);
          expect(selection1.isReversed()).toBeTruthy();
          expect(selection2.getBufferRange()).toEqual([[11, 0], [11, 3]]);
          return expect(selection2.isReversed()).toBeTruthy();
        });
      });
      describe(".selectToEndOfLine()", function() {
        return it("selects text from cusor position to end of line", function() {
          var cursor1, cursor2, ref1, ref2, selection1, selection2;
          editor.setCursorScreenPosition([12, 0]);
          editor.addCursorAtScreenPosition([11, 3]);
          editor.selectToEndOfLine();
          expect(editor.getCursors().length).toBe(2);
          ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
          expect(cursor1.getBufferPosition()).toEqual([12, 2]);
          expect(cursor2.getBufferPosition()).toEqual([11, 44]);
          expect(editor.getSelections().length).toBe(2);
          ref2 = editor.getSelections(), selection1 = ref2[0], selection2 = ref2[1];
          expect(selection1.getBufferRange()).toEqual([[12, 0], [12, 2]]);
          expect(selection1.isReversed()).toBeFalsy();
          expect(selection2.getBufferRange()).toEqual([[11, 3], [11, 44]]);
          return expect(selection2.isReversed()).toBeFalsy();
        });
      });
      describe(".selectLinesContainingCursors()", function() {
        it("selects the entire line (including newlines) at given row", function() {
          editor.setCursorScreenPosition([1, 2]);
          editor.selectLinesContainingCursors();
          expect(editor.getSelectedBufferRange()).toEqual([[1, 0], [2, 0]]);
          expect(editor.getSelectedText()).toBe("  var sort = function(items) {\n");
          editor.setCursorScreenPosition([12, 2]);
          editor.selectLinesContainingCursors();
          expect(editor.getSelectedBufferRange()).toEqual([[12, 0], [12, 2]]);
          editor.setCursorBufferPosition([0, 2]);
          editor.selectLinesContainingCursors();
          editor.selectLinesContainingCursors();
          return expect(editor.getSelectedBufferRange()).toEqual([[0, 0], [2, 0]]);
        });
        return it("autoscrolls to the selection", function() {
          editor.setLineHeightInPixels(10);
          editor.setDefaultCharWidth(10);
          editor.setHeight(50);
          editor.setWidth(50);
          editor.setHorizontalScrollbarHeight(0);
          editor.setCursorScreenPosition([5, 6]);
          editor.scrollToTop();
          expect(editor.getScrollTop()).toBe(0);
          editor.selectLinesContainingCursors();
          return expect(editor.getScrollBottom()).toBe((7 + editor.getVerticalScrollMargin()) * 10);
        });
      });
      describe(".selectToBeginningOfWord()", function() {
        return it("selects text from cusor position to beginning of word", function() {
          var cursor1, cursor2, ref1, ref2, selection1, selection2;
          editor.setCursorScreenPosition([0, 13]);
          editor.addCursorAtScreenPosition([3, 49]);
          editor.selectToBeginningOfWord();
          expect(editor.getCursors().length).toBe(2);
          ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
          expect(cursor1.getBufferPosition()).toEqual([0, 4]);
          expect(cursor2.getBufferPosition()).toEqual([3, 47]);
          expect(editor.getSelections().length).toBe(2);
          ref2 = editor.getSelections(), selection1 = ref2[0], selection2 = ref2[1];
          expect(selection1.getBufferRange()).toEqual([[0, 4], [0, 13]]);
          expect(selection1.isReversed()).toBeTruthy();
          expect(selection2.getBufferRange()).toEqual([[3, 47], [3, 49]]);
          return expect(selection2.isReversed()).toBeTruthy();
        });
      });
      describe(".selectToEndOfWord()", function() {
        return it("selects text from cusor position to end of word", function() {
          var cursor1, cursor2, ref1, ref2, selection1, selection2;
          editor.setCursorScreenPosition([0, 4]);
          editor.addCursorAtScreenPosition([3, 48]);
          editor.selectToEndOfWord();
          expect(editor.getCursors().length).toBe(2);
          ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
          expect(cursor1.getBufferPosition()).toEqual([0, 13]);
          expect(cursor2.getBufferPosition()).toEqual([3, 50]);
          expect(editor.getSelections().length).toBe(2);
          ref2 = editor.getSelections(), selection1 = ref2[0], selection2 = ref2[1];
          expect(selection1.getBufferRange()).toEqual([[0, 4], [0, 13]]);
          expect(selection1.isReversed()).toBeFalsy();
          expect(selection2.getBufferRange()).toEqual([[3, 48], [3, 50]]);
          return expect(selection2.isReversed()).toBeFalsy();
        });
      });
      describe(".selectToBeginningOfNextWord()", function() {
        return it("selects text from cusor position to beginning of next word", function() {
          var cursor1, cursor2, ref1, ref2, selection1, selection2;
          editor.setCursorScreenPosition([0, 4]);
          editor.addCursorAtScreenPosition([3, 48]);
          editor.selectToBeginningOfNextWord();
          expect(editor.getCursors().length).toBe(2);
          ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
          expect(cursor1.getBufferPosition()).toEqual([0, 14]);
          expect(cursor2.getBufferPosition()).toEqual([3, 51]);
          expect(editor.getSelections().length).toBe(2);
          ref2 = editor.getSelections(), selection1 = ref2[0], selection2 = ref2[1];
          expect(selection1.getBufferRange()).toEqual([[0, 4], [0, 14]]);
          expect(selection1.isReversed()).toBeFalsy();
          expect(selection2.getBufferRange()).toEqual([[3, 48], [3, 51]]);
          return expect(selection2.isReversed()).toBeFalsy();
        });
      });
      describe(".selectToPreviousWordBoundary()", function() {
        return it("select to the previous word boundary", function() {
          var ref1, selection1, selection2, selection3, selection4;
          editor.setCursorBufferPosition([0, 8]);
          editor.addCursorAtBufferPosition([2, 0]);
          editor.addCursorAtBufferPosition([3, 4]);
          editor.addCursorAtBufferPosition([3, 14]);
          editor.selectToPreviousWordBoundary();
          expect(editor.getSelections().length).toBe(4);
          ref1 = editor.getSelections(), selection1 = ref1[0], selection2 = ref1[1], selection3 = ref1[2], selection4 = ref1[3];
          expect(selection1.getBufferRange()).toEqual([[0, 8], [0, 4]]);
          expect(selection1.isReversed()).toBeTruthy();
          expect(selection2.getBufferRange()).toEqual([[2, 0], [1, 30]]);
          expect(selection2.isReversed()).toBeTruthy();
          expect(selection3.getBufferRange()).toEqual([[3, 4], [3, 0]]);
          expect(selection3.isReversed()).toBeTruthy();
          expect(selection4.getBufferRange()).toEqual([[3, 14], [3, 13]]);
          return expect(selection4.isReversed()).toBeTruthy();
        });
      });
      describe(".selectToNextWordBoundary()", function() {
        return it("select to the next word boundary", function() {
          var ref1, selection1, selection2, selection3, selection4;
          editor.setCursorBufferPosition([0, 8]);
          editor.addCursorAtBufferPosition([2, 40]);
          editor.addCursorAtBufferPosition([4, 0]);
          editor.addCursorAtBufferPosition([3, 30]);
          editor.selectToNextWordBoundary();
          expect(editor.getSelections().length).toBe(4);
          ref1 = editor.getSelections(), selection1 = ref1[0], selection2 = ref1[1], selection3 = ref1[2], selection4 = ref1[3];
          expect(selection1.getBufferRange()).toEqual([[0, 8], [0, 13]]);
          expect(selection1.isReversed()).toBeFalsy();
          expect(selection2.getBufferRange()).toEqual([[2, 40], [3, 0]]);
          expect(selection2.isReversed()).toBeFalsy();
          expect(selection3.getBufferRange()).toEqual([[4, 0], [4, 4]]);
          expect(selection3.isReversed()).toBeFalsy();
          expect(selection4.getBufferRange()).toEqual([[3, 30], [3, 31]]);
          return expect(selection4.isReversed()).toBeFalsy();
        });
      });
      describe(".selectWordsContainingCursors()", function() {
        describe("when the cursor is inside a word", function() {
          return it("selects the entire word", function() {
            editor.setCursorScreenPosition([0, 8]);
            editor.selectWordsContainingCursors();
            return expect(editor.getSelectedText()).toBe('quicksort');
          });
        });
        describe("when the cursor is between two words", function() {
          return it("selects the word the cursor is on", function() {
            editor.setCursorScreenPosition([0, 4]);
            editor.selectWordsContainingCursors();
            expect(editor.getSelectedText()).toBe('quicksort');
            editor.setCursorScreenPosition([0, 3]);
            editor.selectWordsContainingCursors();
            return expect(editor.getSelectedText()).toBe('var');
          });
        });
        describe("when the cursor is inside a region of whitespace", function() {
          return it("selects the whitespace region", function() {
            editor.setCursorScreenPosition([5, 2]);
            editor.selectWordsContainingCursors();
            expect(editor.getSelectedBufferRange()).toEqual([[5, 0], [5, 6]]);
            editor.setCursorScreenPosition([5, 0]);
            editor.selectWordsContainingCursors();
            return expect(editor.getSelectedBufferRange()).toEqual([[5, 0], [5, 6]]);
          });
        });
        describe("when the cursor is at the end of the text", function() {
          return it("select the previous word", function() {
            editor.buffer.append('word');
            editor.moveToBottom();
            editor.selectWordsContainingCursors();
            return expect(editor.getSelectedBufferRange()).toEqual([[12, 2], [12, 6]]);
          });
        });
        return describe('when editor.nonWordCharacters is set scoped to a grammar', function() {
          var coffeeEditor;
          coffeeEditor = null;
          beforeEach(function() {
            waitsForPromise(function() {
              return atom.packages.activatePackage('language-coffee-script');
            });
            return waitsForPromise(function() {
              return atom.project.open('coffee.coffee', {
                autoIndent: false
              }).then(function(o) {
                return coffeeEditor = o;
              });
            });
          });
          return it('selects the correct surrounding word for the given scoped setting', function() {
            coffeeEditor.setCursorBufferPosition([0, 9]);
            coffeeEditor.selectWordsContainingCursors();
            expect(coffeeEditor.getSelectedBufferRange()).toEqual([[0, 6], [0, 15]]);
            atom.config.set('editor.nonWordCharacters', 'qusort', {
              scopeSelector: '.source.coffee'
            });
            coffeeEditor.setCursorBufferPosition([0, 9]);
            coffeeEditor.selectWordsContainingCursors();
            expect(coffeeEditor.getSelectedBufferRange()).toEqual([[0, 8], [0, 11]]);
            editor.setCursorBufferPosition([0, 7]);
            editor.selectWordsContainingCursors();
            return expect(editor.getSelectedBufferRange()).toEqual([[0, 4], [0, 13]]);
          });
        });
      });
      describe(".selectToFirstCharacterOfLine()", function() {
        return it("moves to the first character of the current line or the beginning of the line if it's already on the first character", function() {
          var cursor1, cursor2, ref1, ref2, ref3, selection1, selection2;
          editor.setCursorScreenPosition([0, 5]);
          editor.addCursorAtScreenPosition([1, 7]);
          editor.selectToFirstCharacterOfLine();
          ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
          expect(cursor1.getBufferPosition()).toEqual([0, 0]);
          expect(cursor2.getBufferPosition()).toEqual([1, 2]);
          expect(editor.getSelections().length).toBe(2);
          ref2 = editor.getSelections(), selection1 = ref2[0], selection2 = ref2[1];
          expect(selection1.getBufferRange()).toEqual([[0, 0], [0, 5]]);
          expect(selection1.isReversed()).toBeTruthy();
          expect(selection2.getBufferRange()).toEqual([[1, 2], [1, 7]]);
          expect(selection2.isReversed()).toBeTruthy();
          editor.selectToFirstCharacterOfLine();
          ref3 = editor.getSelections(), selection1 = ref3[0], selection2 = ref3[1];
          expect(selection1.getBufferRange()).toEqual([[0, 0], [0, 5]]);
          expect(selection1.isReversed()).toBeTruthy();
          expect(selection2.getBufferRange()).toEqual([[1, 0], [1, 7]]);
          return expect(selection2.isReversed()).toBeTruthy();
        });
      });
      describe(".setSelectedBufferRanges(ranges)", function() {
        it("clears existing selections and creates selections for each of the given ranges", function() {
          editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[4, 4], [5, 5]]]);
          expect(editor.getSelectedBufferRanges()).toEqual([[[2, 2], [3, 3]], [[4, 4], [5, 5]]]);
          editor.setSelectedBufferRanges([[[5, 5], [6, 6]]]);
          return expect(editor.getSelectedBufferRanges()).toEqual([[[5, 5], [6, 6]]]);
        });
        it("merges intersecting selections", function() {
          editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[3, 0], [5, 5]]]);
          return expect(editor.getSelectedBufferRanges()).toEqual([[[2, 2], [5, 5]]]);
        });
        it("does not merge non-empty adjacent selections", function() {
          editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[3, 3], [5, 5]]]);
          return expect(editor.getSelectedBufferRanges()).toEqual([[[2, 2], [3, 3]], [[3, 3], [5, 5]]]);
        });
        it("recyles existing selection instances", function() {
          var ref1, selection1, selection2;
          selection = editor.getLastSelection();
          editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[4, 4], [5, 5]]]);
          ref1 = editor.getSelections(), selection1 = ref1[0], selection2 = ref1[1];
          expect(selection1).toBe(selection);
          return expect(selection1.getBufferRange()).toEqual([[2, 2], [3, 3]]);
        });
        describe("when the 'preserveFolds' option is false (the default)", function() {
          return it("removes folds that contain the selections", function() {
            editor.setSelectedBufferRange([[0, 0], [0, 0]]);
            editor.createFold(1, 4);
            editor.createFold(2, 3);
            editor.createFold(6, 8);
            editor.createFold(10, 11);
            editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[6, 6], [7, 7]]]);
            expect(editor.tokenizedLineForScreenRow(1).fold).toBeUndefined();
            expect(editor.tokenizedLineForScreenRow(2).fold).toBeUndefined();
            expect(editor.tokenizedLineForScreenRow(6).fold).toBeUndefined();
            return expect(editor.tokenizedLineForScreenRow(10).fold).toBeDefined();
          });
        });
        return describe("when the 'preserveFolds' option is true", function() {
          return it("does not remove folds that contain the selections", function() {
            editor.setSelectedBufferRange([[0, 0], [0, 0]]);
            editor.createFold(1, 4);
            editor.createFold(6, 8);
            editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[6, 0], [6, 1]]], {
              preserveFolds: true
            });
            expect(editor.isFoldedAtBufferRow(1)).toBeTruthy();
            return expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();
          });
        });
      });
      describe(".setSelectedScreenRanges(ranges)", function() {
        beforeEach(function() {
          return editor.foldBufferRow(4);
        });
        it("clears existing selections and creates selections for each of the given ranges", function() {
          editor.setSelectedScreenRanges([[[3, 4], [3, 7]], [[5, 4], [5, 7]]]);
          expect(editor.getSelectedBufferRanges()).toEqual([[[3, 4], [3, 7]], [[8, 4], [8, 7]]]);
          editor.setSelectedScreenRanges([[[6, 2], [6, 4]]]);
          return expect(editor.getSelectedScreenRanges()).toEqual([[[6, 2], [6, 4]]]);
        });
        it("merges intersecting selections and unfolds the fold which contain them", function() {
          editor.foldBufferRow(0);
          editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[3, 0], [5, 5]]]);
          return expect(editor.getSelectedBufferRanges()).toEqual([[[2, 2], [5, 5]]]);
        });
        return it("recyles existing selection instances", function() {
          var ref1, selection1, selection2;
          selection = editor.getLastSelection();
          editor.setSelectedScreenRanges([[[2, 2], [3, 4]], [[4, 4], [5, 5]]]);
          ref1 = editor.getSelections(), selection1 = ref1[0], selection2 = ref1[1];
          expect(selection1).toBe(selection);
          return expect(selection1.getScreenRange()).toEqual([[2, 2], [3, 4]]);
        });
      });
      describe(".setSelectedBufferRange(range)", function() {
        return it("autoscrolls the selection if it is last unless the 'autoscroll' option is false", function() {
          editor.setVerticalScrollMargin(2);
          editor.setHorizontalScrollMargin(2);
          editor.setLineHeightInPixels(10);
          editor.setDefaultCharWidth(10);
          editor.setHeight(70);
          editor.setWidth(100);
          editor.setHorizontalScrollbarHeight(0);
          expect(editor.getScrollTop()).toBe(0);
          editor.setSelectedBufferRange([[5, 6], [6, 8]]);
          expect(editor.getScrollBottom()).toBe((7 + editor.getVerticalScrollMargin()) * 10);
          expect(editor.getScrollRight()).toBe((8 + editor.getHorizontalScrollMargin()) * 10);
          editor.setSelectedBufferRange([[0, 0], [0, 0]]);
          expect(editor.getScrollTop()).toBe(0);
          expect(editor.getScrollLeft()).toBe(0);
          editor.setSelectedBufferRange([[6, 6], [6, 8]]);
          expect(editor.getScrollBottom()).toBe((7 + editor.getVerticalScrollMargin()) * 10);
          return expect(editor.getScrollRight()).toBe((8 + editor.getHorizontalScrollMargin()) * 10);
        });
      });
      describe(".selectMarker(marker)", function() {
        describe("if the marker is valid", function() {
          return it("selects the marker's range and returns the selected range", function() {
            var marker;
            marker = editor.markBufferRange([[0, 1], [3, 3]]);
            expect(editor.selectMarker(marker)).toEqual([[0, 1], [3, 3]]);
            return expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [3, 3]]);
          });
        });
        return describe("if the marker is invalid", function() {
          return it("does not change the selection and returns a falsy value", function() {
            var marker;
            marker = editor.markBufferRange([[0, 1], [3, 3]]);
            marker.destroy();
            expect(editor.selectMarker(marker)).toBeFalsy();
            return expect(editor.getSelectedBufferRange()).toEqual([[0, 0], [0, 0]]);
          });
        });
      });
      describe(".addSelectionForBufferRange(bufferRange)", function() {
        it("adds a selection for the specified buffer range", function() {
          editor.addSelectionForBufferRange([[3, 4], [5, 6]]);
          return expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [0, 0]], [[3, 4], [5, 6]]]);
        });
        return it("autoscrolls to the added selection if needed", function() {
          editor.setVerticalScrollMargin(2);
          editor.setHorizontalScrollMargin(2);
          editor.setLineHeightInPixels(10);
          editor.setDefaultCharWidth(10);
          editor.setHeight(80);
          editor.setWidth(100);
          editor.addSelectionForBufferRange([[8, 10], [8, 15]]);
          expect(editor.getScrollBottom()).toBe((9 * 10) + (2 * 10));
          return expect(editor.getScrollRight()).toBe((15 * 10) + (2 * 10));
        });
      });
      describe(".addSelectionBelow()", function() {
        describe("when the selection is non-empty", function() {
          it("selects the same region of the line below current selections if possible", function() {
            var cursor, i, len, ref1, results;
            editor.setSelectedBufferRange([[3, 16], [3, 21]]);
            editor.addSelectionForBufferRange([[3, 25], [3, 34]]);
            editor.addSelectionBelow();
            expect(editor.getSelectedBufferRanges()).toEqual([[[3, 16], [3, 21]], [[3, 25], [3, 34]], [[4, 16], [4, 21]], [[4, 25], [4, 29]]]);
            ref1 = editor.getCursors();
            results = [];
            for (i = 0, len = ref1.length; i < len; i++) {
              cursor = ref1[i];
              results.push(expect(cursor.isVisible()).toBeFalsy());
            }
            return results;
          });
          it("skips lines that are too short to create a non-empty selection", function() {
            editor.setSelectedBufferRange([[3, 31], [3, 38]]);
            editor.addSelectionBelow();
            return expect(editor.getSelectedBufferRanges()).toEqual([[[3, 31], [3, 38]], [[6, 31], [6, 38]]]);
          });
          it("honors the original selection's range (goal range) when adding across shorter lines", function() {
            editor.setSelectedBufferRange([[3, 22], [3, 38]]);
            editor.addSelectionBelow();
            editor.addSelectionBelow();
            editor.addSelectionBelow();
            return expect(editor.getSelectedBufferRanges()).toEqual([[[3, 22], [3, 38]], [[4, 22], [4, 29]], [[5, 22], [5, 30]], [[6, 22], [6, 38]]]);
          });
          it("clears selection goal ranges when the selection changes", function() {
            editor.setSelectedBufferRange([[3, 22], [3, 38]]);
            editor.addSelectionBelow();
            editor.selectLeft();
            editor.addSelectionBelow();
            expect(editor.getSelectedBufferRanges()).toEqual([[[3, 22], [3, 37]], [[4, 22], [4, 29]], [[5, 22], [5, 28]]]);
            editor.addSelectionBelow();
            return expect(editor.getSelectedBufferRanges()).toEqual([[[3, 22], [3, 37]], [[4, 22], [4, 29]], [[5, 22], [5, 30]], [[6, 22], [6, 28]]]);
          });
          it("can add selections to soft-wrapped line segments", function() {
            editor.setSoftWrapped(true);
            editor.setEditorWidthInChars(40);
            editor.setSelectedScreenRange([[3, 10], [3, 15]]);
            editor.addSelectionBelow();
            return expect(editor.getSelectedScreenRanges()).toEqual([[[3, 10], [3, 15]], [[4, 10], [4, 15]]]);
          });
          return it("takes atomic tokens into account", function() {
            waitsForPromise(function() {
              return atom.project.open('sample-with-tabs-and-leading-comment.coffee', {
                autoIndent: false
              }).then(function(o) {
                return editor = o;
              });
            });
            return runs(function() {
              editor.setSelectedBufferRange([[2, 1], [2, 3]]);
              editor.addSelectionBelow();
              return expect(editor.getSelectedBufferRanges()).toEqual([[[2, 1], [2, 3]], [[3, 1], [3, 2]]]);
            });
          });
        });
        return describe("when the selection is empty", function() {
          describe("when lines are soft-wrapped", function() {
            beforeEach(function() {
              editor.setSoftWrapped(true);
              return editor.setEditorWidthInChars(40);
            });
            it("skips soft-wrap indentation tokens", function() {
              editor.setCursorScreenPosition([3, 0]);
              editor.addSelectionBelow();
              return expect(editor.getSelectedScreenRanges()).toEqual([[[3, 0], [3, 0]], [[4, 4], [4, 4]]]);
            });
            return it("does not skip them if they're shorter than the current column", function() {
              editor.setCursorScreenPosition([3, 37]);
              editor.addSelectionBelow();
              return expect(editor.getSelectedScreenRanges()).toEqual([[[3, 37], [3, 37]], [[4, 26], [4, 26]]]);
            });
          });
          it("does not skip lines that are shorter than the current column", function() {
            editor.setCursorBufferPosition([3, 36]);
            editor.addSelectionBelow();
            editor.addSelectionBelow();
            editor.addSelectionBelow();
            return expect(editor.getSelectedBufferRanges()).toEqual([[[3, 36], [3, 36]], [[4, 29], [4, 29]], [[5, 30], [5, 30]], [[6, 36], [6, 36]]]);
          });
          it("skips empty lines when the column is non-zero", function() {
            editor.setCursorBufferPosition([9, 4]);
            editor.addSelectionBelow();
            return expect(editor.getSelectedBufferRanges()).toEqual([[[9, 4], [9, 4]], [[11, 4], [11, 4]]]);
          });
          return it("does not skip empty lines when the column is zero", function() {
            editor.setCursorBufferPosition([9, 0]);
            editor.addSelectionBelow();
            return expect(editor.getSelectedBufferRanges()).toEqual([[[9, 0], [9, 0]], [[10, 0], [10, 0]]]);
          });
        });
      });
      describe(".addSelectionAbove()", function() {
        describe("when the selection is non-empty", function() {
          it("selects the same region of the line above current selections if possible", function() {
            var cursor, i, len, ref1, results;
            editor.setSelectedBufferRange([[3, 16], [3, 21]]);
            editor.addSelectionForBufferRange([[3, 37], [3, 44]]);
            editor.addSelectionAbove();
            expect(editor.getSelectedBufferRanges()).toEqual([[[3, 16], [3, 21]], [[3, 37], [3, 44]], [[2, 16], [2, 21]], [[2, 37], [2, 40]]]);
            ref1 = editor.getCursors();
            results = [];
            for (i = 0, len = ref1.length; i < len; i++) {
              cursor = ref1[i];
              results.push(expect(cursor.isVisible()).toBeFalsy());
            }
            return results;
          });
          it("skips lines that are too short to create a non-empty selection", function() {
            editor.setSelectedBufferRange([[6, 31], [6, 38]]);
            editor.addSelectionAbove();
            return expect(editor.getSelectedBufferRanges()).toEqual([[[6, 31], [6, 38]], [[3, 31], [3, 38]]]);
          });
          it("honors the original selection's range (goal range) when adding across shorter lines", function() {
            editor.setSelectedBufferRange([[6, 22], [6, 38]]);
            editor.addSelectionAbove();
            editor.addSelectionAbove();
            editor.addSelectionAbove();
            return expect(editor.getSelectedBufferRanges()).toEqual([[[6, 22], [6, 38]], [[5, 22], [5, 30]], [[4, 22], [4, 29]], [[3, 22], [3, 38]]]);
          });
          it("can add selections to soft-wrapped line segments", function() {
            editor.setSoftWrapped(true);
            editor.setEditorWidthInChars(40);
            editor.setSelectedScreenRange([[4, 10], [4, 15]]);
            editor.addSelectionAbove();
            return expect(editor.getSelectedScreenRanges()).toEqual([[[4, 10], [4, 15]], [[3, 10], [3, 15]]]);
          });
          return it("takes atomic tokens into account", function() {
            waitsForPromise(function() {
              return atom.project.open('sample-with-tabs-and-leading-comment.coffee', {
                autoIndent: false
              }).then(function(o) {
                return editor = o;
              });
            });
            return runs(function() {
              editor.setSelectedBufferRange([[3, 1], [3, 2]]);
              editor.addSelectionAbove();
              return expect(editor.getSelectedBufferRanges()).toEqual([[[3, 1], [3, 2]], [[2, 1], [2, 3]]]);
            });
          });
        });
        return describe("when the selection is empty", function() {
          describe("when lines are soft-wrapped", function() {
            beforeEach(function() {
              editor.setSoftWrapped(true);
              return editor.setEditorWidthInChars(40);
            });
            it("skips soft-wrap indentation tokens", function() {
              editor.setCursorScreenPosition([5, 0]);
              editor.addSelectionAbove();
              return expect(editor.getSelectedScreenRanges()).toEqual([[[5, 0], [5, 0]], [[4, 4], [4, 4]]]);
            });
            return it("does not skip them if they're shorter than the current column", function() {
              editor.setCursorScreenPosition([5, 29]);
              editor.addSelectionAbove();
              return expect(editor.getSelectedScreenRanges()).toEqual([[[5, 29], [5, 29]], [[4, 26], [4, 26]]]);
            });
          });
          it("does not skip lines that are shorter than the current column", function() {
            editor.setCursorBufferPosition([6, 36]);
            editor.addSelectionAbove();
            editor.addSelectionAbove();
            editor.addSelectionAbove();
            return expect(editor.getSelectedBufferRanges()).toEqual([[[6, 36], [6, 36]], [[5, 30], [5, 30]], [[4, 29], [4, 29]], [[3, 36], [3, 36]]]);
          });
          it("skips empty lines when the column is non-zero", function() {
            editor.setCursorBufferPosition([11, 4]);
            editor.addSelectionAbove();
            return expect(editor.getSelectedBufferRanges()).toEqual([[[11, 4], [11, 4]], [[9, 4], [9, 4]]]);
          });
          return it("does not skip empty lines when the column is zero", function() {
            editor.setCursorBufferPosition([10, 0]);
            editor.addSelectionAbove();
            return expect(editor.getSelectedBufferRanges()).toEqual([[[10, 0], [10, 0]], [[9, 0], [9, 0]]]);
          });
        });
      });
      describe(".splitSelectionsIntoLines()", function() {
        return it("splits all multi-line selections into one selection per line", function() {
          editor.setSelectedBufferRange([[0, 3], [2, 4]]);
          editor.splitSelectionsIntoLines();
          expect(editor.getSelectedBufferRanges()).toEqual([[[0, 3], [0, 29]], [[1, 0], [1, 30]], [[2, 0], [2, 4]]]);
          editor.setSelectedBufferRange([[0, 3], [1, 10]]);
          editor.splitSelectionsIntoLines();
          expect(editor.getSelectedBufferRanges()).toEqual([[[0, 3], [0, 29]], [[1, 0], [1, 10]]]);
          editor.setSelectedBufferRange([[0, 0], [0, 3]]);
          editor.splitSelectionsIntoLines();
          return expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [0, 3]]]);
        });
      });
      describe(".consolidateSelections()", function() {
        return it("destroys all selections but the most recent, returning true if any selections were destroyed", function() {
          var selection1, selection2, selection3;
          editor.setSelectedBufferRange([[3, 16], [3, 21]]);
          selection1 = editor.getLastSelection();
          selection2 = editor.addSelectionForBufferRange([[3, 25], [3, 34]]);
          selection3 = editor.addSelectionForBufferRange([[8, 4], [8, 10]]);
          expect(editor.getSelections()).toEqual([selection1, selection2, selection3]);
          expect(editor.consolidateSelections()).toBeTruthy();
          expect(editor.getSelections()).toEqual([selection3]);
          expect(selection3.isEmpty()).toBeFalsy();
          expect(editor.consolidateSelections()).toBeFalsy();
          return expect(editor.getSelections()).toEqual([selection3]);
        });
      });
      describe("when the cursor is moved while there is a selection", function() {
        var makeSelection;
        makeSelection = function() {
          return selection.setBufferRange([[1, 2], [1, 5]]);
        };
        return it("clears the selection", function() {
          makeSelection();
          editor.moveDown();
          expect(selection.isEmpty()).toBeTruthy();
          makeSelection();
          editor.moveUp();
          expect(selection.isEmpty()).toBeTruthy();
          makeSelection();
          editor.moveLeft();
          expect(selection.isEmpty()).toBeTruthy();
          makeSelection();
          editor.moveRight();
          expect(selection.isEmpty()).toBeTruthy();
          makeSelection();
          editor.setCursorScreenPosition([3, 3]);
          return expect(selection.isEmpty()).toBeTruthy();
        });
      });
      return it("does not share selections between different edit sessions for the same buffer", function() {
        var editor2;
        editor2 = null;
        waitsForPromise(function() {
          return atom.project.open('sample.js').then(function(o) {
            return editor2 = o;
          });
        });
        return runs(function() {
          editor.setSelectedBufferRanges([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]);
          editor2.setSelectedBufferRanges([[[8, 7], [6, 5]], [[4, 3], [2, 1]]]);
          return expect(editor2.getSelectedBufferRanges()).not.toEqual(editor.getSelectedBufferRanges());
        });
      });
    });
    describe("buffer manipulation", function() {
      describe(".insertText(text)", function() {
        describe("when there is a single selection", function() {
          beforeEach(function() {
            return editor.setSelectedBufferRange([[1, 0], [1, 2]]);
          });
          return it("replaces the selection with the given text", function() {
            var range;
            range = editor.insertText('xxx');
            expect(range).toEqual([[[1, 0], [1, 3]]]);
            return expect(buffer.lineForRow(1)).toBe('xxxvar sort = function(items) {');
          });
        });
        describe("when there are multiple empty selections", function() {
          describe("when the cursors are on the same line", function() {
            return it("inserts the given text at the location of each cursor and moves the cursors to the end of each cursor's inserted text", function() {
              var cursor1, cursor2, ref1;
              editor.setCursorScreenPosition([1, 2]);
              editor.addCursorAtScreenPosition([1, 5]);
              editor.insertText('xxx');
              expect(buffer.lineForRow(1)).toBe('  xxxvarxxx sort = function(items) {');
              ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
              expect(cursor1.getBufferPosition()).toEqual([1, 5]);
              return expect(cursor2.getBufferPosition()).toEqual([1, 11]);
            });
          });
          return describe("when the cursors are on different lines", function() {
            it("inserts the given text at the location of each cursor and moves the cursors to the end of each cursor's inserted text", function() {
              var cursor1, cursor2, ref1;
              editor.setCursorScreenPosition([1, 2]);
              editor.addCursorAtScreenPosition([2, 4]);
              editor.insertText('xxx');
              expect(buffer.lineForRow(1)).toBe('  xxxvar sort = function(items) {');
              expect(buffer.lineForRow(2)).toBe('    xxxif (items.length <= 1) return items;');
              ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
              expect(cursor1.getBufferPosition()).toEqual([1, 5]);
              return expect(cursor2.getBufferPosition()).toEqual([2, 7]);
            });
            return it("autoscrolls to the last cursor", function() {
              editor.setCursorScreenPosition([1, 2]);
              editor.addCursorAtScreenPosition([10, 4]);
              editor.setLineHeightInPixels(10);
              editor.setHeight(50);
              expect(editor.getScrollTop()).toBe(0);
              editor.insertText('a');
              return expect(editor.getScrollTop()).toBe(80);
            });
          });
        });
        describe("when there are multiple non-empty selections", function() {
          describe("when the selections are on the same line", function() {
            return it("replaces each selection range with the inserted characters", function() {
              var cursor1, cursor2, ref1, ref2, selection1, selection2;
              editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[0, 22], [0, 24]]]);
              editor.insertText("x");
              ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
              ref2 = editor.getSelections(), selection1 = ref2[0], selection2 = ref2[1];
              expect(cursor1.getScreenPosition()).toEqual([0, 5]);
              expect(cursor2.getScreenPosition()).toEqual([0, 15]);
              expect(selection1.isEmpty()).toBeTruthy();
              expect(selection2.isEmpty()).toBeTruthy();
              return expect(editor.lineTextForBufferRow(0)).toBe("var x = functix () {");
            });
          });
          return describe("when the selections are on different lines", function() {
            return it("replaces each selection with the given text, clears the selections, and places the cursor at the end of each selection's inserted text", function() {
              var ref1, selection1, selection2;
              editor.setSelectedBufferRanges([[[1, 0], [1, 2]], [[2, 0], [2, 4]]]);
              editor.insertText('xxx');
              expect(buffer.lineForRow(1)).toBe('xxxvar sort = function(items) {');
              expect(buffer.lineForRow(2)).toBe('xxxif (items.length <= 1) return items;');
              ref1 = editor.getSelections(), selection1 = ref1[0], selection2 = ref1[1];
              expect(selection1.isEmpty()).toBeTruthy();
              expect(selection1.cursor.getBufferPosition()).toEqual([1, 3]);
              expect(selection2.isEmpty()).toBeTruthy();
              return expect(selection2.cursor.getBufferPosition()).toEqual([2, 3]);
            });
          });
        });
        describe("when there is a selection that ends on a folded line", function() {
          return it("destroys the selection", function() {
            editor.createFold(2, 4);
            editor.setSelectedBufferRange([[1, 0], [2, 0]]);
            editor.insertText('holy cow');
            return expect(editor.tokenizedLineForScreenRow(2).fold).toBeUndefined();
          });
        });
        describe("when there are ::onWillInsertText and ::onDidInsertText observers", function() {
          beforeEach(function() {
            return editor.setSelectedBufferRange([[1, 0], [1, 2]]);
          });
          it("notifies the observers when inserting text", function() {
            var didInsertSpy, options, willInsertSpy;
            willInsertSpy = jasmine.createSpy().andCallFake(function() {
              return expect(buffer.lineForRow(1)).toBe('  var sort = function(items) {');
            });
            didInsertSpy = jasmine.createSpy().andCallFake(function() {
              return expect(buffer.lineForRow(1)).toBe('xxxvar sort = function(items) {');
            });
            editor.onWillInsertText(willInsertSpy);
            editor.onDidInsertText(didInsertSpy);
            expect(editor.insertText('xxx')).toBeTruthy();
            expect(buffer.lineForRow(1)).toBe('xxxvar sort = function(items) {');
            expect(willInsertSpy).toHaveBeenCalled();
            expect(didInsertSpy).toHaveBeenCalled();
            options = willInsertSpy.mostRecentCall.args[0];
            expect(options.text).toBe('xxx');
            expect(options.cancel).toBeDefined();
            options = didInsertSpy.mostRecentCall.args[0];
            return expect(options.text).toBe('xxx');
          });
          return it("cancels text insertion when an ::onWillInsertText observer calls cancel on an event", function() {
            var didInsertSpy, willInsertSpy;
            willInsertSpy = jasmine.createSpy().andCallFake(function(arg) {
              var cancel;
              cancel = arg.cancel;
              return cancel();
            });
            didInsertSpy = jasmine.createSpy();
            editor.onWillInsertText(willInsertSpy);
            editor.onDidInsertText(didInsertSpy);
            expect(editor.insertText('xxx')).toBe(false);
            expect(buffer.lineForRow(1)).toBe('  var sort = function(items) {');
            expect(willInsertSpy).toHaveBeenCalled();
            return expect(didInsertSpy).not.toHaveBeenCalled();
          });
        });
        return describe("when the undo option is set to 'skip'", function() {
          beforeEach(function() {
            return editor.setSelectedBufferRange([[1, 2], [1, 2]]);
          });
          return it("does not undo the skipped operation", function() {
            var range;
            range = editor.insertText('x');
            range = editor.insertText('y', {
              undo: 'skip'
            });
            editor.undo();
            return expect(buffer.lineForRow(1)).toBe('  yvar sort = function(items) {');
          });
        });
      });
      describe(".insertNewline()", function() {
        describe("when there is a single cursor", function() {
          describe("when the cursor is at the beginning of a line", function() {
            return it("inserts an empty line before it", function() {
              editor.setCursorScreenPosition({
                row: 1,
                column: 0
              });
              editor.insertNewline();
              expect(buffer.lineForRow(1)).toBe('');
              return expect(editor.getCursorScreenPosition()).toEqual({
                row: 2,
                column: 0
              });
            });
          });
          describe("when the cursor is in the middle of a line", function() {
            return it("splits the current line to form a new line", function() {
              var lineBelowOriginalLine, originalLine;
              editor.setCursorScreenPosition({
                row: 1,
                column: 6
              });
              originalLine = buffer.lineForRow(1);
              lineBelowOriginalLine = buffer.lineForRow(2);
              editor.insertNewline();
              expect(buffer.lineForRow(1)).toBe(originalLine.slice(0, 6));
              expect(buffer.lineForRow(2)).toBe(originalLine.slice(6));
              expect(buffer.lineForRow(3)).toBe(lineBelowOriginalLine);
              return expect(editor.getCursorScreenPosition()).toEqual({
                row: 2,
                column: 0
              });
            });
          });
          return describe("when the cursor is on the end of a line", function() {
            return it("inserts an empty line after it", function() {
              editor.setCursorScreenPosition({
                row: 1,
                column: buffer.lineForRow(1).length
              });
              editor.insertNewline();
              expect(buffer.lineForRow(2)).toBe('');
              return expect(editor.getCursorScreenPosition()).toEqual({
                row: 2,
                column: 0
              });
            });
          });
        });
        return describe("when there are multiple cursors", function() {
          describe("when the cursors are on the same line", function() {
            return it("breaks the line at the cursor locations", function() {
              var cursor1, cursor2, ref1;
              editor.setCursorScreenPosition([3, 13]);
              editor.addCursorAtScreenPosition([3, 38]);
              editor.insertNewline();
              expect(editor.lineTextForBufferRow(3)).toBe("    var pivot");
              expect(editor.lineTextForBufferRow(4)).toBe(" = items.shift(), current");
              expect(editor.lineTextForBufferRow(5)).toBe(", left = [], right = [];");
              expect(editor.lineTextForBufferRow(6)).toBe("    while(items.length > 0) {");
              ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
              expect(cursor1.getBufferPosition()).toEqual([4, 0]);
              return expect(cursor2.getBufferPosition()).toEqual([5, 0]);
            });
          });
          return describe("when the cursors are on different lines", function() {
            return it("inserts newlines at each cursor location", function() {
              var cursor1, cursor2, ref1;
              editor.setCursorScreenPosition([3, 0]);
              editor.addCursorAtScreenPosition([6, 0]);
              editor.insertText("\n");
              expect(editor.lineTextForBufferRow(3)).toBe("");
              expect(editor.lineTextForBufferRow(4)).toBe("    var pivot = items.shift(), current, left = [], right = [];");
              expect(editor.lineTextForBufferRow(5)).toBe("    while(items.length > 0) {");
              expect(editor.lineTextForBufferRow(6)).toBe("      current = items.shift();");
              expect(editor.lineTextForBufferRow(7)).toBe("");
              expect(editor.lineTextForBufferRow(8)).toBe("      current < pivot ? left.push(current) : right.push(current);");
              expect(editor.lineTextForBufferRow(9)).toBe("    }");
              ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
              expect(cursor1.getBufferPosition()).toEqual([4, 0]);
              return expect(cursor2.getBufferPosition()).toEqual([8, 0]);
            });
          });
        });
      });
      describe(".insertNewlineBelow()", function() {
        describe("when the operation is undone", function() {
          return it("places the cursor back at the previous location", function() {
            editor.setCursorBufferPosition([0, 2]);
            editor.insertNewlineBelow();
            expect(editor.getCursorBufferPosition()).toEqual([1, 0]);
            editor.undo();
            return expect(editor.getCursorBufferPosition()).toEqual([0, 2]);
          });
        });
        return it("inserts a newline below the cursor's current line, autoindents it, and moves the cursor to the end of the line", function() {
          atom.config.set("editor.autoIndent", true);
          editor.insertNewlineBelow();
          expect(buffer.lineForRow(0)).toBe("var quicksort = function () {");
          expect(buffer.lineForRow(1)).toBe("  ");
          return expect(editor.getCursorBufferPosition()).toEqual([1, 2]);
        });
      });
      describe(".insertNewlineAbove()", function() {
        describe("when the cursor is on first line", function() {
          return it("inserts a newline on the first line and moves the cursor to the first line", function() {
            editor.setCursorBufferPosition([0]);
            editor.insertNewlineAbove();
            expect(editor.getCursorBufferPosition()).toEqual([0, 0]);
            expect(editor.lineTextForBufferRow(0)).toBe('');
            expect(editor.lineTextForBufferRow(1)).toBe('var quicksort = function () {');
            return expect(editor.buffer.getLineCount()).toBe(14);
          });
        });
        describe("when the cursor is not on the first line", function() {
          return it("inserts a newline above the current line and moves the cursor to the inserted line", function() {
            editor.setCursorBufferPosition([3, 4]);
            editor.insertNewlineAbove();
            expect(editor.getCursorBufferPosition()).toEqual([3, 0]);
            expect(editor.lineTextForBufferRow(3)).toBe('');
            expect(editor.lineTextForBufferRow(4)).toBe('    var pivot = items.shift(), current, left = [], right = [];');
            expect(editor.buffer.getLineCount()).toBe(14);
            editor.undo();
            return expect(editor.getCursorBufferPosition()).toEqual([3, 4]);
          });
        });
        return it("indents the new line to the correct level when editor.autoIndent is true", function() {
          atom.config.set('editor.autoIndent', true);
          editor.setText('  var test');
          editor.setCursorBufferPosition([0, 2]);
          editor.insertNewlineAbove();
          expect(editor.getCursorBufferPosition()).toEqual([0, 2]);
          expect(editor.lineTextForBufferRow(0)).toBe('  ');
          expect(editor.lineTextForBufferRow(1)).toBe('  var test');
          editor.setText('\n  var test');
          editor.setCursorBufferPosition([1, 2]);
          editor.insertNewlineAbove();
          expect(editor.getCursorBufferPosition()).toEqual([1, 2]);
          expect(editor.lineTextForBufferRow(0)).toBe('');
          expect(editor.lineTextForBufferRow(1)).toBe('  ');
          expect(editor.lineTextForBufferRow(2)).toBe('  var test');
          editor.setText('function() {\n}');
          editor.setCursorBufferPosition([1, 1]);
          editor.insertNewlineAbove();
          expect(editor.getCursorBufferPosition()).toEqual([1, 2]);
          expect(editor.lineTextForBufferRow(0)).toBe('function() {');
          expect(editor.lineTextForBufferRow(1)).toBe('  ');
          return expect(editor.lineTextForBufferRow(2)).toBe('}');
        });
      });
      describe(".insertNewLine()", function() {
        describe("when a new line is appended before a closing tag (e.g. by pressing enter before a selection)", function() {
          return it("moves the line down and keeps the indentation level the same when editor.autoIndent is true", function() {
            atom.config.set('editor.autoIndent', true);
            editor.setCursorBufferPosition([9, 2]);
            editor.insertNewline();
            return expect(editor.lineTextForBufferRow(10)).toBe('  };');
          });
        });
        describe("when a newline is appended with a trailing closing tag behind the cursor (e.g. by pressing enter in the middel of a line)", function() {
          it("indents the new line to the correct level when editor.autoIndent is true and using a curly-bracket language", function() {
            waitsForPromise(function() {
              return atom.packages.activatePackage('language-javascript');
            });
            return runs(function() {
              atom.config.set("editor.autoIndent", true);
              editor.setGrammar(atom.grammars.selectGrammar("file.js"));
              editor.setText('var test = function () {\n  return true;};');
              editor.setCursorBufferPosition([1, 14]);
              editor.insertNewline();
              expect(editor.indentationForBufferRow(1)).toBe(1);
              return expect(editor.indentationForBufferRow(2)).toBe(0);
            });
          });
          it("indents the new line to the current level when editor.autoIndent is true and no increaseIndentPattern is specified", function() {
            return runs(function() {
              atom.config.set("editor.autoIndent", true);
              editor.setGrammar(atom.grammars.selectGrammar("file"));
              editor.setText('  if true');
              editor.setCursorBufferPosition([0, 8]);
              editor.insertNewline();
              expect(editor.getGrammar()).toBe(atom.grammars.nullGrammar);
              expect(editor.indentationForBufferRow(0)).toBe(1);
              return expect(editor.indentationForBufferRow(1)).toBe(1);
            });
          });
          return it("indents the new line to the correct level when editor.autoIndent is true and using a off-side rule language", function() {
            waitsForPromise(function() {
              return atom.packages.activatePackage('language-coffee-script');
            });
            return runs(function() {
              atom.config.set("editor.autoIndent", true);
              editor.setGrammar(atom.grammars.selectGrammar("file.coffee"));
              editor.setText('if true\n  return trueelse\n  return false');
              editor.setCursorBufferPosition([1, 13]);
              editor.insertNewline();
              expect(editor.indentationForBufferRow(1)).toBe(1);
              expect(editor.indentationForBufferRow(2)).toBe(0);
              return expect(editor.indentationForBufferRow(3)).toBe(1);
            });
          });
        });
        return describe("when a newline is appended on a line that matches the decreaseNextIndentPattern", function() {
          return it("indents the new line to the correct level when editor.autoIndent is true", function() {
            waitsForPromise(function() {
              return atom.packages.activatePackage('language-go');
            });
            return runs(function() {
              atom.config.set("editor.autoIndent", true);
              editor.setGrammar(atom.grammars.selectGrammar("file.go"));
              editor.setText('fmt.Printf("some%s",\n	"thing")');
              editor.setCursorBufferPosition([1, 10]);
              editor.insertNewline();
              expect(editor.indentationForBufferRow(1)).toBe(1);
              return expect(editor.indentationForBufferRow(2)).toBe(0);
            });
          });
        });
      });
      describe(".backspace()", function() {
        describe("when there is a single cursor", function() {
          var changeScreenRangeHandler;
          changeScreenRangeHandler = null;
          beforeEach(function() {
            var selection;
            selection = editor.getLastSelection();
            changeScreenRangeHandler = jasmine.createSpy('changeScreenRangeHandler');
            return selection.onDidChangeRange(changeScreenRangeHandler);
          });
          describe("when the cursor is on the middle of the line", function() {
            return it("removes the character before the cursor", function() {
              var line;
              editor.setCursorScreenPosition({
                row: 1,
                column: 7
              });
              expect(buffer.lineForRow(1)).toBe("  var sort = function(items) {");
              editor.backspace();
              line = buffer.lineForRow(1);
              expect(line).toBe("  var ort = function(items) {");
              expect(editor.getCursorScreenPosition()).toEqual({
                row: 1,
                column: 6
              });
              expect(changeScreenRangeHandler).toHaveBeenCalled();
              return expect(editor.getLastCursor().isVisible()).toBeTruthy();
            });
          });
          describe("when the cursor is at the beginning of a line", function() {
            return it("joins it with the line above", function() {
              var line0, line1, originalLine0;
              originalLine0 = buffer.lineForRow(0);
              expect(originalLine0).toBe("var quicksort = function () {");
              expect(buffer.lineForRow(1)).toBe("  var sort = function(items) {");
              editor.setCursorScreenPosition({
                row: 1,
                column: 0
              });
              editor.backspace();
              line0 = buffer.lineForRow(0);
              line1 = buffer.lineForRow(1);
              expect(line0).toBe("var quicksort = function () {  var sort = function(items) {");
              expect(line1).toBe("    if (items.length <= 1) return items;");
              expect(editor.getCursorScreenPosition()).toEqual([0, originalLine0.length]);
              return expect(changeScreenRangeHandler).toHaveBeenCalled();
            });
          });
          describe("when the cursor is at the first column of the first line", function() {
            return it("does nothing, but doesn't raise an error", function() {
              editor.setCursorScreenPosition({
                row: 0,
                column: 0
              });
              return editor.backspace();
            });
          });
          describe("when the cursor is on the first column of a line below a fold", function() {
            return it("deletes the folded lines", function() {
              editor.setCursorScreenPosition([4, 0]);
              editor.foldCurrentRow();
              editor.setCursorScreenPosition([5, 0]);
              editor.backspace();
              expect(buffer.lineForRow(4)).toBe("    return sort(left).concat(pivot).concat(sort(right));");
              return expect(buffer.lineForRow(4).fold).toBeUndefined();
            });
          });
          describe("when the cursor is in the middle of a line below a fold", function() {
            return it("backspaces as normal", function() {
              editor.setCursorScreenPosition([4, 0]);
              editor.foldCurrentRow();
              editor.setCursorScreenPosition([5, 5]);
              editor.backspace();
              expect(buffer.lineForRow(7)).toBe("    }");
              return expect(buffer.lineForRow(8)).toBe("    eturn sort(left).concat(pivot).concat(sort(right));");
            });
          });
          return describe("when the cursor is on a folded screen line", function() {
            return it("deletes all of the folded lines along with the fold", function() {
              editor.setCursorBufferPosition([3, 0]);
              editor.foldCurrentRow();
              editor.backspace();
              expect(buffer.lineForRow(1)).toBe("");
              expect(buffer.lineForRow(2)).toBe("  return sort(Array.apply(this, arguments));");
              return expect(editor.getCursorScreenPosition()).toEqual([1, 0]);
            });
          });
        });
        describe("when there are multiple cursors", function() {
          describe("when cursors are on the same line", function() {
            return it("removes the characters preceding each cursor", function() {
              var cursor1, cursor2, ref1, ref2, selection1, selection2;
              editor.setCursorScreenPosition([3, 13]);
              editor.addCursorAtScreenPosition([3, 38]);
              editor.backspace();
              expect(editor.lineTextForBufferRow(3)).toBe("    var pivo = items.shift(), curren, left = [], right = [];");
              ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
              expect(cursor1.getBufferPosition()).toEqual([3, 12]);
              expect(cursor2.getBufferPosition()).toEqual([3, 36]);
              ref2 = editor.getSelections(), selection1 = ref2[0], selection2 = ref2[1];
              expect(selection1.isEmpty()).toBeTruthy();
              return expect(selection2.isEmpty()).toBeTruthy();
            });
          });
          return describe("when cursors are on different lines", function() {
            describe("when the cursors are in the middle of their lines", function() {
              return it("removes the characters preceding each cursor", function() {
                var cursor1, cursor2, ref1, ref2, selection1, selection2;
                editor.setCursorScreenPosition([3, 13]);
                editor.addCursorAtScreenPosition([4, 10]);
                editor.backspace();
                expect(editor.lineTextForBufferRow(3)).toBe("    var pivo = items.shift(), current, left = [], right = [];");
                expect(editor.lineTextForBufferRow(4)).toBe("    whileitems.length > 0) {");
                ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
                expect(cursor1.getBufferPosition()).toEqual([3, 12]);
                expect(cursor2.getBufferPosition()).toEqual([4, 9]);
                ref2 = editor.getSelections(), selection1 = ref2[0], selection2 = ref2[1];
                expect(selection1.isEmpty()).toBeTruthy();
                return expect(selection2.isEmpty()).toBeTruthy();
              });
            });
            return describe("when the cursors are on the first column of their lines", function() {
              return it("removes the newlines preceding each cursor", function() {
                var cursor1, cursor2, ref1;
                editor.setCursorScreenPosition([3, 0]);
                editor.addCursorAtScreenPosition([6, 0]);
                editor.backspace();
                expect(editor.lineTextForBufferRow(2)).toBe("    if (items.length <= 1) return items;    var pivot = items.shift(), current, left = [], right = [];");
                expect(editor.lineTextForBufferRow(3)).toBe("    while(items.length > 0) {");
                expect(editor.lineTextForBufferRow(4)).toBe("      current = items.shift();      current < pivot ? left.push(current) : right.push(current);");
                expect(editor.lineTextForBufferRow(5)).toBe("    }");
                ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
                expect(cursor1.getBufferPosition()).toEqual([2, 40]);
                return expect(cursor2.getBufferPosition()).toEqual([4, 30]);
              });
            });
          });
        });
        describe("when there is a single selection", function() {
          it("deletes the selection, but not the character before it", function() {
            editor.setSelectedBufferRange([[0, 5], [0, 9]]);
            editor.backspace();
            return expect(editor.buffer.lineForRow(0)).toBe('var qsort = function () {');
          });
          return describe("when the selection ends on a folded line", function() {
            return it("preserves the fold", function() {
              editor.setSelectedBufferRange([[3, 0], [4, 0]]);
              editor.foldBufferRow(4);
              editor.backspace();
              expect(buffer.lineForRow(3)).toBe("    while(items.length > 0) {");
              return expect(editor.tokenizedLineForScreenRow(3).fold).toBeDefined();
            });
          });
        });
        return describe("when there are multiple selections", function() {
          return it("removes all selected text", function() {
            editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[0, 16], [0, 24]]]);
            editor.backspace();
            return expect(editor.lineTextForBufferRow(0)).toBe('var  =  () {');
          });
        });
      });
      describe(".deleteToPreviousWordBoundary()", function() {
        describe("when no text is selected", function() {
          return it("deletes to the previous word boundary", function() {
            var cursor1, cursor2, ref1;
            editor.setCursorBufferPosition([0, 16]);
            editor.addCursorAtBufferPosition([1, 21]);
            ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
            editor.deleteToPreviousWordBoundary();
            expect(buffer.lineForRow(0)).toBe('var quicksort =function () {');
            expect(buffer.lineForRow(1)).toBe('  var sort = (items) {');
            expect(cursor1.getBufferPosition()).toEqual([0, 15]);
            expect(cursor2.getBufferPosition()).toEqual([1, 13]);
            editor.deleteToPreviousWordBoundary();
            expect(buffer.lineForRow(0)).toBe('var quicksort function () {');
            expect(buffer.lineForRow(1)).toBe('  var sort =(items) {');
            expect(cursor1.getBufferPosition()).toEqual([0, 14]);
            return expect(cursor2.getBufferPosition()).toEqual([1, 12]);
          });
        });
        return describe("when text is selected", function() {
          return it("deletes only selected text", function() {
            editor.setSelectedBufferRange([[1, 24], [1, 27]]);
            editor.deleteToPreviousWordBoundary();
            return expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');
          });
        });
      });
      describe(".deleteToNextWordBoundary()", function() {
        describe("when no text is selected", function() {
          return it("deletes to the next word boundary", function() {
            var cursor1, cursor2, ref1;
            editor.setCursorBufferPosition([0, 15]);
            editor.addCursorAtBufferPosition([1, 24]);
            ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
            editor.deleteToNextWordBoundary();
            expect(buffer.lineForRow(0)).toBe('var quicksort =function () {');
            expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');
            expect(cursor1.getBufferPosition()).toEqual([0, 15]);
            expect(cursor2.getBufferPosition()).toEqual([1, 24]);
            editor.deleteToNextWordBoundary();
            expect(buffer.lineForRow(0)).toBe('var quicksort = () {');
            expect(buffer.lineForRow(1)).toBe('  var sort = function(it {');
            expect(cursor1.getBufferPosition()).toEqual([0, 15]);
            expect(cursor2.getBufferPosition()).toEqual([1, 24]);
            editor.deleteToNextWordBoundary();
            expect(buffer.lineForRow(0)).toBe('var quicksort =() {');
            expect(buffer.lineForRow(1)).toBe('  var sort = function(it{');
            expect(cursor1.getBufferPosition()).toEqual([0, 15]);
            return expect(cursor2.getBufferPosition()).toEqual([1, 24]);
          });
        });
        return describe("when text is selected", function() {
          return it("deletes only selected text", function() {
            editor.setSelectedBufferRange([[1, 24], [1, 27]]);
            editor.deleteToNextWordBoundary();
            return expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');
          });
        });
      });
      describe(".deleteToBeginningOfWord()", function() {
        describe("when no text is selected", function() {
          return it("deletes all text between the cursor and the beginning of the word", function() {
            var cursor1, cursor2, ref1;
            editor.setCursorBufferPosition([1, 24]);
            editor.addCursorAtBufferPosition([3, 5]);
            ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
            editor.deleteToBeginningOfWord();
            expect(buffer.lineForRow(1)).toBe('  var sort = function(ems) {');
            expect(buffer.lineForRow(3)).toBe('    ar pivot = items.shift(), current, left = [], right = [];');
            expect(cursor1.getBufferPosition()).toEqual([1, 22]);
            expect(cursor2.getBufferPosition()).toEqual([3, 4]);
            editor.deleteToBeginningOfWord();
            expect(buffer.lineForRow(1)).toBe('  var sort = functionems) {');
            expect(buffer.lineForRow(2)).toBe('    if (items.length <= 1) return itemsar pivot = items.shift(), current, left = [], right = [];');
            expect(cursor1.getBufferPosition()).toEqual([1, 21]);
            expect(cursor2.getBufferPosition()).toEqual([2, 39]);
            editor.deleteToBeginningOfWord();
            expect(buffer.lineForRow(1)).toBe('  var sort = ems) {');
            expect(buffer.lineForRow(2)).toBe('    if (items.length <= 1) return ar pivot = items.shift(), current, left = [], right = [];');
            expect(cursor1.getBufferPosition()).toEqual([1, 13]);
            expect(cursor2.getBufferPosition()).toEqual([2, 34]);
            editor.setText('  var sort');
            editor.setCursorBufferPosition([0, 2]);
            editor.deleteToBeginningOfWord();
            return expect(buffer.lineForRow(0)).toBe('var sort');
          });
        });
        return describe("when text is selected", function() {
          return it("deletes only selected text", function() {
            editor.setSelectedBufferRanges([[[1, 24], [1, 27]], [[2, 0], [2, 4]]]);
            editor.deleteToBeginningOfWord();
            expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');
            return expect(buffer.lineForRow(2)).toBe('if (items.length <= 1) return items;');
          });
        });
      });
      describe('.deleteToEndOfLine()', function() {
        describe('when no text is selected', function() {
          it('deletes all text between the cursor and the end of the line', function() {
            var cursor1, cursor2, ref1;
            editor.setCursorBufferPosition([1, 24]);
            editor.addCursorAtBufferPosition([2, 5]);
            ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
            editor.deleteToEndOfLine();
            expect(buffer.lineForRow(1)).toBe('  var sort = function(it');
            expect(buffer.lineForRow(2)).toBe('    i');
            expect(cursor1.getBufferPosition()).toEqual([1, 24]);
            return expect(cursor2.getBufferPosition()).toEqual([2, 5]);
          });
          return describe('when at the end of the line', function() {
            return it('deletes the next newline', function() {
              editor.setCursorBufferPosition([1, 30]);
              editor.deleteToEndOfLine();
              return expect(buffer.lineForRow(1)).toBe('  var sort = function(items) {    if (items.length <= 1) return items;');
            });
          });
        });
        return describe('when text is selected', function() {
          return it('deletes only the text in the selection', function() {
            editor.setSelectedBufferRanges([[[1, 24], [1, 27]], [[2, 0], [2, 4]]]);
            editor.deleteToEndOfLine();
            expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');
            return expect(buffer.lineForRow(2)).toBe('if (items.length <= 1) return items;');
          });
        });
      });
      describe(".deleteToBeginningOfLine()", function() {
        describe("when no text is selected", function() {
          it("deletes all text between the cursor and the beginning of the line", function() {
            var cursor1, cursor2, ref1;
            editor.setCursorBufferPosition([1, 24]);
            editor.addCursorAtBufferPosition([2, 5]);
            ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
            editor.deleteToBeginningOfLine();
            expect(buffer.lineForRow(1)).toBe('ems) {');
            expect(buffer.lineForRow(2)).toBe('f (items.length <= 1) return items;');
            expect(cursor1.getBufferPosition()).toEqual([1, 0]);
            return expect(cursor2.getBufferPosition()).toEqual([2, 0]);
          });
          return describe("when at the beginning of the line", function() {
            return it("deletes the newline", function() {
              editor.setCursorBufferPosition([2]);
              editor.deleteToBeginningOfLine();
              return expect(buffer.lineForRow(1)).toBe('  var sort = function(items) {    if (items.length <= 1) return items;');
            });
          });
        });
        return describe("when text is selected", function() {
          return it("still deletes all text to begginning of the line", function() {
            editor.setSelectedBufferRanges([[[1, 24], [1, 27]], [[2, 0], [2, 4]]]);
            editor.deleteToBeginningOfLine();
            expect(buffer.lineForRow(1)).toBe('ems) {');
            return expect(buffer.lineForRow(2)).toBe('    if (items.length <= 1) return items;');
          });
        });
      });
      describe(".delete()", function() {
        describe("when there is a single cursor", function() {
          describe("when the cursor is on the middle of a line", function() {
            return it("deletes the character following the cursor", function() {
              editor.setCursorScreenPosition([1, 6]);
              editor["delete"]();
              return expect(buffer.lineForRow(1)).toBe('  var ort = function(items) {');
            });
          });
          describe("when the cursor is on the end of a line", function() {
            return it("joins the line with the following line", function() {
              editor.setCursorScreenPosition([1, buffer.lineForRow(1).length]);
              editor["delete"]();
              return expect(buffer.lineForRow(1)).toBe('  var sort = function(items) {    if (items.length <= 1) return items;');
            });
          });
          describe("when the cursor is on the last column of the last line", function() {
            return it("does nothing, but doesn't raise an error", function() {
              editor.setCursorScreenPosition([12, buffer.lineForRow(12).length]);
              editor["delete"]();
              return expect(buffer.lineForRow(12)).toBe('};');
            });
          });
          describe("when the cursor is on the end of a line above a fold", function() {
            return it("only deletes the lines inside the fold", function() {
              var cursorPositionBefore;
              editor.foldBufferRow(4);
              editor.setCursorScreenPosition([3, Infinity]);
              cursorPositionBefore = editor.getCursorScreenPosition();
              editor["delete"]();
              expect(buffer.lineForRow(3)).toBe("    var pivot = items.shift(), current, left = [], right = [];");
              expect(buffer.lineForRow(4)).toBe("    return sort(left).concat(pivot).concat(sort(right));");
              return expect(editor.getCursorScreenPosition()).toEqual(cursorPositionBefore);
            });
          });
          describe("when the cursor is in the middle a line above a fold", function() {
            return it("deletes as normal", function() {
              var cursorPositionBefore;
              editor.foldBufferRow(4);
              editor.setCursorScreenPosition([3, 4]);
              cursorPositionBefore = editor.getCursorScreenPosition();
              editor["delete"]();
              expect(buffer.lineForRow(3)).toBe("    ar pivot = items.shift(), current, left = [], right = [];");
              expect(editor.tokenizedLineForScreenRow(4).fold).toBeDefined();
              return expect(editor.getCursorScreenPosition()).toEqual([3, 4]);
            });
          });
          return describe("when the cursor is on a folded line", function() {
            return it("removes the lines contained by the fold", function() {
              var oldLine7, oldLine8;
              editor.setSelectedBufferRange([[2, 0], [2, 0]]);
              editor.createFold(2, 4);
              editor.createFold(2, 6);
              oldLine7 = buffer.lineForRow(7);
              oldLine8 = buffer.lineForRow(8);
              editor["delete"]();
              expect(editor.tokenizedLineForScreenRow(2).text).toBe(oldLine7);
              return expect(editor.tokenizedLineForScreenRow(3).text).toBe(oldLine8);
            });
          });
        });
        describe("when there are multiple cursors", function() {
          describe("when cursors are on the same line", function() {
            return it("removes the characters following each cursor", function() {
              var cursor1, cursor2, ref1, ref2, selection1, selection2;
              editor.setCursorScreenPosition([3, 13]);
              editor.addCursorAtScreenPosition([3, 38]);
              editor["delete"]();
              expect(editor.lineTextForBufferRow(3)).toBe("    var pivot= items.shift(), current left = [], right = [];");
              ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
              expect(cursor1.getBufferPosition()).toEqual([3, 13]);
              expect(cursor2.getBufferPosition()).toEqual([3, 37]);
              ref2 = editor.getSelections(), selection1 = ref2[0], selection2 = ref2[1];
              expect(selection1.isEmpty()).toBeTruthy();
              return expect(selection2.isEmpty()).toBeTruthy();
            });
          });
          return describe("when cursors are on different lines", function() {
            describe("when the cursors are in the middle of the lines", function() {
              return it("removes the characters following each cursor", function() {
                var cursor1, cursor2, ref1, ref2, selection1, selection2;
                editor.setCursorScreenPosition([3, 13]);
                editor.addCursorAtScreenPosition([4, 10]);
                editor["delete"]();
                expect(editor.lineTextForBufferRow(3)).toBe("    var pivot= items.shift(), current, left = [], right = [];");
                expect(editor.lineTextForBufferRow(4)).toBe("    while(tems.length > 0) {");
                ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
                expect(cursor1.getBufferPosition()).toEqual([3, 13]);
                expect(cursor2.getBufferPosition()).toEqual([4, 10]);
                ref2 = editor.getSelections(), selection1 = ref2[0], selection2 = ref2[1];
                expect(selection1.isEmpty()).toBeTruthy();
                return expect(selection2.isEmpty()).toBeTruthy();
              });
            });
            return describe("when the cursors are at the end of their lines", function() {
              return it("removes the newlines following each cursor", function() {
                var cursor1, cursor2, ref1;
                editor.setCursorScreenPosition([0, 29]);
                editor.addCursorAtScreenPosition([1, 30]);
                editor["delete"]();
                expect(editor.lineTextForBufferRow(0)).toBe("var quicksort = function () {  var sort = function(items) {    if (items.length <= 1) return items;");
                ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
                expect(cursor1.getBufferPosition()).toEqual([0, 29]);
                return expect(cursor2.getBufferPosition()).toEqual([0, 59]);
              });
            });
          });
        });
        describe("when there is a single selection", function() {
          return it("deletes the selection, but not the character following it", function() {
            editor.setSelectedBufferRanges([[[1, 24], [1, 27]], [[2, 0], [2, 4]]]);
            editor["delete"]();
            expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');
            expect(buffer.lineForRow(2)).toBe('if (items.length <= 1) return items;');
            return expect(editor.getLastSelection().isEmpty()).toBeTruthy();
          });
        });
        return describe("when there are multiple selections", function() {
          return describe("when selections are on the same line", function() {
            return it("removes all selected text", function() {
              editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[0, 16], [0, 24]]]);
              editor["delete"]();
              return expect(editor.lineTextForBufferRow(0)).toBe('var  =  () {');
            });
          });
        });
      });
      describe(".deleteToEndOfWord()", function() {
        describe("when no text is selected", function() {
          return it("deletes to the end of the word", function() {
            var cursor1, cursor2, ref1;
            editor.setCursorBufferPosition([1, 24]);
            editor.addCursorAtBufferPosition([2, 5]);
            ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
            editor.deleteToEndOfWord();
            expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');
            expect(buffer.lineForRow(2)).toBe('    i (items.length <= 1) return items;');
            expect(cursor1.getBufferPosition()).toEqual([1, 24]);
            expect(cursor2.getBufferPosition()).toEqual([2, 5]);
            editor.deleteToEndOfWord();
            expect(buffer.lineForRow(1)).toBe('  var sort = function(it {');
            expect(buffer.lineForRow(2)).toBe('    iitems.length <= 1) return items;');
            expect(cursor1.getBufferPosition()).toEqual([1, 24]);
            return expect(cursor2.getBufferPosition()).toEqual([2, 5]);
          });
        });
        return describe("when text is selected", function() {
          return it("deletes only selected text", function() {
            editor.setSelectedBufferRange([[1, 24], [1, 27]]);
            editor.deleteToEndOfWord();
            return expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');
          });
        });
      });
      describe(".indent()", function() {
        describe("when the selection is empty", function() {
          describe("when autoIndent is disabled", function() {
            describe("if 'softTabs' is true (the default)", function() {
              it("inserts 'tabLength' spaces into the buffer", function() {
                var tabRegex;
                tabRegex = new RegExp("^[ ]{" + (editor.getTabLength()) + "}");
                expect(buffer.lineForRow(0)).not.toMatch(tabRegex);
                editor.indent();
                return expect(buffer.lineForRow(0)).toMatch(tabRegex);
              });
              return it("respects the tab stops when cursor is in the middle of a tab", function() {
                editor.setTabLength(4);
                buffer.insert([12, 2], "\n ");
                editor.setCursorBufferPosition([13, 1]);
                editor.indent();
                expect(buffer.lineForRow(13)).toMatch(/^\s+$/);
                expect(buffer.lineForRow(13).length).toBe(4);
                expect(editor.getCursorBufferPosition()).toEqual([13, 4]);
                buffer.insert([13, 0], "  ");
                editor.setCursorBufferPosition([13, 6]);
                editor.indent();
                return expect(buffer.lineForRow(13).length).toBe(8);
              });
            });
            return describe("if 'softTabs' is false", function() {
              return it("insert a \t into the buffer", function() {
                editor.setSoftTabs(false);
                expect(buffer.lineForRow(0)).not.toMatch(/^\t/);
                editor.indent();
                return expect(buffer.lineForRow(0)).toMatch(/^\t/);
              });
            });
          });
          return describe("when autoIndent is enabled", function() {
            describe("when the cursor's column is less than the suggested level of indentation", function() {
              describe("when 'softTabs' is true (the default)", function() {
                it("moves the cursor to the end of the leading whitespace and inserts enough whitespace to bring the line to the suggested level of indentaion", function() {
                  buffer.insert([5, 0], "  \n");
                  editor.setCursorBufferPosition([5, 0]);
                  editor.indent({
                    autoIndent: true
                  });
                  expect(buffer.lineForRow(5)).toMatch(/^\s+$/);
                  expect(buffer.lineForRow(5).length).toBe(6);
                  return expect(editor.getCursorBufferPosition()).toEqual([5, 6]);
                });
                return it("respects the tab stops when cursor is in the middle of a tab", function() {
                  editor.setTabLength(4);
                  buffer.insert([12, 2], "\n ");
                  editor.setCursorBufferPosition([13, 1]);
                  editor.indent({
                    autoIndent: true
                  });
                  expect(buffer.lineForRow(13)).toMatch(/^\s+$/);
                  expect(buffer.lineForRow(13).length).toBe(4);
                  expect(editor.getCursorBufferPosition()).toEqual([13, 4]);
                  buffer.insert([13, 0], "  ");
                  editor.setCursorBufferPosition([13, 6]);
                  editor.indent({
                    autoIndent: true
                  });
                  return expect(buffer.lineForRow(13).length).toBe(8);
                });
              });
              return describe("when 'softTabs' is false", function() {
                it("moves the cursor to the end of the leading whitespace and inserts enough tabs to bring the line to the suggested level of indentaion", function() {
                  convertToHardTabs(buffer);
                  editor.setSoftTabs(false);
                  buffer.insert([5, 0], "\t\n");
                  editor.setCursorBufferPosition([5, 0]);
                  editor.indent({
                    autoIndent: true
                  });
                  expect(buffer.lineForRow(5)).toMatch(/^\t\t\t$/);
                  return expect(editor.getCursorBufferPosition()).toEqual([5, 3]);
                });
                return describe("when the difference between the suggested level of indentation and the current level of indentation is greater than 0 but less than 1", function() {
                  return it("inserts one tab", function() {
                    editor.setSoftTabs(false);
                    buffer.setText(" \ntest");
                    editor.setCursorBufferPosition([1, 0]);
                    editor.indent({
                      autoIndent: true
                    });
                    expect(buffer.lineForRow(1)).toBe('\ttest');
                    return expect(editor.getCursorBufferPosition()).toEqual([1, 1]);
                  });
                });
              });
            });
            return describe("when the line's indent level is greater than the suggested level of indentation", function() {
              describe("when 'softTabs' is true (the default)", function() {
                return it("moves the cursor to the end of the leading whitespace and inserts 'tabLength' spaces into the buffer", function() {
                  buffer.insert([7, 0], "      \n");
                  editor.setCursorBufferPosition([7, 2]);
                  editor.indent({
                    autoIndent: true
                  });
                  expect(buffer.lineForRow(7)).toMatch(/^\s+$/);
                  expect(buffer.lineForRow(7).length).toBe(8);
                  return expect(editor.getCursorBufferPosition()).toEqual([7, 8]);
                });
              });
              return describe("when 'softTabs' is false", function() {
                return it("moves the cursor to the end of the leading whitespace and inserts \t into the buffer", function() {
                  convertToHardTabs(buffer);
                  editor.setSoftTabs(false);
                  buffer.insert([7, 0], "\t\t\t\n");
                  editor.setCursorBufferPosition([7, 1]);
                  editor.indent({
                    autoIndent: true
                  });
                  expect(buffer.lineForRow(7)).toMatch(/^\t\t\t\t$/);
                  return expect(editor.getCursorBufferPosition()).toEqual([7, 4]);
                });
              });
            });
          });
        });
        describe("when the selection is not empty", function() {
          return it("indents the selected lines", function() {
            var selection;
            editor.setSelectedBufferRange([[0, 0], [10, 0]]);
            selection = editor.getLastSelection();
            spyOn(selection, "indentSelectedRows");
            editor.indent();
            return expect(selection.indentSelectedRows).toHaveBeenCalled();
          });
        });
        return describe("if editor.softTabs is false", function() {
          return it("inserts a tab character into the buffer", function() {
            editor.setSoftTabs(false);
            expect(buffer.lineForRow(0)).not.toMatch(/^\t/);
            editor.indent();
            expect(buffer.lineForRow(0)).toMatch(/^\t/);
            expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
            expect(editor.getCursorScreenPosition()).toEqual([0, editor.getTabLength()]);
            editor.indent();
            expect(buffer.lineForRow(0)).toMatch(/^\t\t/);
            expect(editor.getCursorBufferPosition()).toEqual([0, 2]);
            return expect(editor.getCursorScreenPosition()).toEqual([0, editor.getTabLength() * 2]);
          });
        });
      });
      describe("clipboard operations", function() {
        describe(".cutSelectedText()", function() {
          it("removes the selected text from the buffer and places it on the clipboard", function() {
            editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[1, 6], [1, 10]]]);
            editor.cutSelectedText();
            expect(buffer.lineForRow(0)).toBe("var  = function () {");
            expect(buffer.lineForRow(1)).toBe("  var  = function(items) {");
            return expect(clipboard.readText()).toBe('quicksort\nsort');
          });
          describe("when no text is selected", function() {
            beforeEach(function() {
              return editor.setSelectedBufferRanges([[[0, 0], [0, 0]], [[5, 0], [5, 0]]]);
            });
            return it("cuts the lines on which there are cursors", function() {
              editor.cutSelectedText();
              expect(buffer.getLineCount()).toBe(11);
              expect(buffer.lineForRow(1)).toBe("    if (items.length <= 1) return items;");
              expect(buffer.lineForRow(4)).toBe("      current < pivot ? left.push(current) : right.push(current);");
              return expect(atom.clipboard.read()).toEqual("var quicksort = function () {\n\n      current = items.shift();\n");
            });
          });
          return describe("when many selections get added in shuffle order", function() {
            return it("cuts them in order", function() {
              editor.setSelectedBufferRanges([[[2, 8], [2, 13]], [[0, 4], [0, 13]], [[1, 6], [1, 10]]]);
              editor.cutSelectedText();
              return expect(atom.clipboard.read()).toEqual("quicksort\nsort\nitems");
            });
          });
        });
        describe(".cutToEndOfLine()", function() {
          describe("when soft wrap is on", function() {
            return it("cuts up to the end of the line", function() {
              editor.setSoftWrapped(true);
              editor.setEditorWidthInChars(10);
              editor.setCursorScreenPosition([2, 2]);
              editor.cutToEndOfLine();
              return expect(editor.tokenizedLineForScreenRow(2).text).toBe('=  () {');
            });
          });
          return describe("when soft wrap is off", function() {
            describe("when nothing is selected", function() {
              return it("cuts up to the end of the line", function() {
                editor.setCursorBufferPosition([2, 20]);
                editor.addCursorAtBufferPosition([3, 20]);
                editor.cutToEndOfLine();
                expect(buffer.lineForRow(2)).toBe('    if (items.length');
                expect(buffer.lineForRow(3)).toBe('    var pivot = item');
                return expect(atom.clipboard.read()).toBe(' <= 1) return items;\ns.shift(), current, left = [], right = [];');
              });
            });
            return describe("when text is selected", function() {
              return it("only cuts the selected text, not to the end of the line", function() {
                editor.setSelectedBufferRanges([[[2, 20], [2, 30]], [[3, 20], [3, 20]]]);
                editor.cutToEndOfLine();
                expect(buffer.lineForRow(2)).toBe('    if (items.lengthurn items;');
                expect(buffer.lineForRow(3)).toBe('    var pivot = item');
                return expect(atom.clipboard.read()).toBe(' <= 1) ret\ns.shift(), current, left = [], right = [];');
              });
            });
          });
        });
        describe(".copySelectedText()", function() {
          it("copies selected text onto the clipboard", function() {
            editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[1, 6], [1, 10]], [[2, 8], [2, 13]]]);
            editor.copySelectedText();
            expect(buffer.lineForRow(0)).toBe("var quicksort = function () {");
            expect(buffer.lineForRow(1)).toBe("  var sort = function(items) {");
            expect(buffer.lineForRow(2)).toBe("    if (items.length <= 1) return items;");
            expect(clipboard.readText()).toBe('quicksort\nsort\nitems');
            return expect(atom.clipboard.read()).toEqual("quicksort\nsort\nitems");
          });
          describe("when no text is selected", function() {
            beforeEach(function() {
              return editor.setSelectedBufferRanges([[[1, 5], [1, 5]], [[5, 8], [5, 8]]]);
            });
            return it("copies the lines on which there are cursors", function() {
              editor.copySelectedText();
              expect(atom.clipboard.read()).toEqual(["  var sort = function(items) {\n", "      current = items.shift();\n"].join("\n"));
              return expect(editor.getSelectedBufferRanges()).toEqual([[[1, 5], [1, 5]], [[5, 8], [5, 8]]]);
            });
          });
          return describe("when many selections get added in shuffle order", function() {
            return it("copies them in order", function() {
              editor.setSelectedBufferRanges([[[2, 8], [2, 13]], [[0, 4], [0, 13]], [[1, 6], [1, 10]]]);
              editor.copySelectedText();
              return expect(atom.clipboard.read()).toEqual("quicksort\nsort\nitems");
            });
          });
        });
        return describe(".pasteText()", function() {
          var copyText;
          copyText = function(text, arg) {
            var endColumn, numberOfNewlines, ref1, ref2, ref3, startColumn, textEditor;
            ref1 = arg != null ? arg : {}, startColumn = ref1.startColumn, textEditor = ref1.textEditor;
            if (startColumn == null) {
              startColumn = 0;
            }
            if (textEditor == null) {
              textEditor = editor;
            }
            textEditor.setCursorBufferPosition([0, 0]);
            textEditor.insertText(text);
            numberOfNewlines = (ref2 = text.match(/\n/g)) != null ? ref2.length : void 0;
            endColumn = (ref3 = text.match(/[^\n]*$/)[0]) != null ? ref3.length : void 0;
            textEditor.getLastSelection().setBufferRange([[0, startColumn], [numberOfNewlines, endColumn]]);
            return textEditor.cutSelectedText();
          };
          it("pastes text into the buffer", function() {
            editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[1, 6], [1, 10]]]);
            atom.clipboard.write('first');
            editor.pasteText();
            expect(editor.lineTextForBufferRow(0)).toBe("var first = function () {");
            return expect(editor.lineTextForBufferRow(1)).toBe("  var first = function(items) {");
          });
          it("notifies ::onWillInsertText observers", function() {
            var insertedStrings;
            insertedStrings = [];
            editor.onWillInsertText(function(arg) {
              var cancel, text;
              text = arg.text, cancel = arg.cancel;
              insertedStrings.push(text);
              return cancel();
            });
            atom.clipboard.write("hello");
            editor.pasteText();
            return expect(insertedStrings).toEqual(["hello"]);
          });
          it("notifies ::onDidInsertText observers", function() {
            var insertedStrings;
            insertedStrings = [];
            editor.onDidInsertText(function(arg) {
              var range, text;
              text = arg.text, range = arg.range;
              return insertedStrings.push(text);
            });
            atom.clipboard.write("hello");
            editor.pasteText();
            return expect(insertedStrings).toEqual(["hello"]);
          });
          describe("when `autoIndentOnPaste` is true", function() {
            beforeEach(function() {
              return atom.config.set("editor.autoIndentOnPaste", true);
            });
            describe("when pasting multiple lines before any non-whitespace characters", function() {
              it("auto-indents the lines spanned by the pasted text, based on the first pasted line", function() {
                atom.clipboard.write("a(x);\n  b(x);\n    c(x);\n", {
                  indentBasis: 0
                });
                editor.setCursorBufferPosition([5, 0]);
                editor.pasteText();
                expect(editor.lineTextForBufferRow(5)).toBe("      a(x);");
                expect(editor.lineTextForBufferRow(6)).toBe("        b(x);");
                expect(editor.lineTextForBufferRow(7)).toBe("          c(x);");
                return expect(editor.lineTextForBufferRow(8)).toBe("      current = items.shift();");
              });
              return it("auto-indents lines with a mix of hard tabs and spaces without removing spaces", function() {
                editor.setSoftTabs(false);
                expect(editor.indentationForBufferRow(5)).toBe(3);
                atom.clipboard.write("/**\n\t * testing\n\t * indent\n\t **/\n", {
                  indentBasis: 1
                });
                editor.setCursorBufferPosition([5, 0]);
                editor.pasteText();
                expect(editor.lineTextForBufferRow(5)).toBe("\t\t\t/**");
                expect(editor.lineTextForBufferRow(6)).toBe("\t\t\t * testing");
                expect(editor.lineTextForBufferRow(7)).toBe("\t\t\t * indent");
                return expect(editor.lineTextForBufferRow(8)).toBe("\t\t\t **/");
              });
            });
            describe("when pasting line(s) above a line that matches the decreaseIndentPattern", function() {
              return it("auto-indents based on the pasted line(s) only", function() {
                atom.clipboard.write("a(x);\n  b(x);\n    c(x);\n", {
                  indentBasis: 0
                });
                editor.setCursorBufferPosition([7, 0]);
                editor.pasteText();
                expect(editor.lineTextForBufferRow(7)).toBe("      a(x);");
                expect(editor.lineTextForBufferRow(8)).toBe("        b(x);");
                expect(editor.lineTextForBufferRow(9)).toBe("          c(x);");
                return expect(editor.lineTextForBufferRow(10)).toBe("    }");
              });
            });
            describe("when pasting a line of text without line ending", function() {
              return it("does not auto-indent the text", function() {
                atom.clipboard.write("a(x);", {
                  indentBasis: 0
                });
                editor.setCursorBufferPosition([5, 0]);
                editor.pasteText();
                expect(editor.lineTextForBufferRow(5)).toBe("a(x);      current = items.shift();");
                return expect(editor.lineTextForBufferRow(6)).toBe("      current < pivot ? left.push(current) : right.push(current);");
              });
            });
            return describe("when pasting on a line after non-whitespace characters", function() {
              return it("does not auto-indent the affected line", function() {
                editor.setText("if (x) {\n    y();\n}");
                atom.clipboard.write(" z();\n h();");
                editor.setCursorBufferPosition([1, Infinity]);
                editor.pasteText();
                expect(editor.lineTextForBufferRow(1)).toBe("    y(); z();");
                return expect(editor.lineTextForBufferRow(2)).toBe(" h();");
              });
            });
          });
          describe("when `autoIndentOnPaste` is false", function() {
            beforeEach(function() {
              return atom.config.set('editor.autoIndentOnPaste', false);
            });
            describe("when the cursor is indented further than the original copied text", function() {
              return it("increases the indentation of the copied lines to match", function() {
                editor.setSelectedBufferRange([[1, 2], [3, 0]]);
                editor.copySelectedText();
                editor.setCursorBufferPosition([5, 6]);
                editor.pasteText();
                expect(editor.lineTextForBufferRow(5)).toBe("      var sort = function(items) {");
                return expect(editor.lineTextForBufferRow(6)).toBe("        if (items.length <= 1) return items;");
              });
            });
            describe("when the cursor is indented less far than the original copied text", function() {
              return it("decreases the indentation of the copied lines to match", function() {
                editor.setSelectedBufferRange([[6, 6], [8, 0]]);
                editor.copySelectedText();
                editor.setCursorBufferPosition([1, 2]);
                editor.pasteText();
                expect(editor.lineTextForBufferRow(1)).toBe("  current < pivot ? left.push(current) : right.push(current);");
                return expect(editor.lineTextForBufferRow(2)).toBe("}");
              });
            });
            return describe("when the first copied line has leading whitespace", function() {
              return it("preserves the line's leading whitespace", function() {
                editor.setSelectedBufferRange([[4, 0], [6, 0]]);
                editor.copySelectedText();
                editor.setCursorBufferPosition([0, 0]);
                editor.pasteText();
                expect(editor.lineTextForBufferRow(0)).toBe("    while(items.length > 0) {");
                return expect(editor.lineTextForBufferRow(1)).toBe("      current = items.shift();");
              });
            });
          });
          describe('when the clipboard has many selections', function() {
            beforeEach(function() {
              atom.config.set("editor.autoIndentOnPaste", false);
              editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[1, 6], [1, 10]]]);
              return editor.copySelectedText();
            });
            it("pastes each selection in order separately into the buffer", function() {
              editor.setSelectedBufferRanges([[[1, 6], [1, 10]], [[0, 4], [0, 13]]]);
              editor.moveRight();
              editor.insertText("_");
              editor.pasteText();
              expect(editor.lineTextForBufferRow(0)).toBe("var quicksort_quicksort = function () {");
              return expect(editor.lineTextForBufferRow(1)).toBe("  var sort_sort = function(items) {");
            });
            return describe('and the selections count does not match', function() {
              beforeEach(function() {
                return editor.setSelectedBufferRanges([[[0, 4], [0, 13]]]);
              });
              return it("pastes the whole text into the buffer", function() {
                editor.pasteText();
                expect(editor.lineTextForBufferRow(0)).toBe("var quicksort");
                return expect(editor.lineTextForBufferRow(1)).toBe("sort = function () {");
              });
            });
          });
          describe("when a full line was cut", function() {
            beforeEach(function() {
              editor.setCursorBufferPosition([2, 13]);
              editor.cutSelectedText();
              return editor.setCursorBufferPosition([2, 13]);
            });
            return it("pastes the line above the cursor and retains the cursor's column", function() {
              editor.pasteText();
              expect(editor.lineTextForBufferRow(2)).toBe("    if (items.length <= 1) return items;");
              expect(editor.lineTextForBufferRow(3)).toBe("    var pivot = items.shift(), current, left = [], right = [];");
              return expect(editor.getCursorBufferPosition()).toEqual([3, 13]);
            });
          });
          return describe("when a full line was copied", function() {
            beforeEach(function() {
              editor.setCursorBufferPosition([2, 13]);
              return editor.copySelectedText();
            });
            describe("when there is a selection", function() {
              return it("overwrites the selection as with any copied text", function() {
                editor.setSelectedBufferRange([[1, 2], [1, Infinity]]);
                editor.pasteText();
                expect(editor.lineTextForBufferRow(1)).toBe("  if (items.length <= 1) return items;");
                expect(editor.lineTextForBufferRow(2)).toBe("");
                expect(editor.lineTextForBufferRow(3)).toBe("    if (items.length <= 1) return items;");
                return expect(editor.getCursorBufferPosition()).toEqual([2, 0]);
              });
            });
            return describe("when there is no selection", function() {
              return it("pastes the line above the cursor and retains the cursor's column", function() {
                editor.pasteText();
                expect(editor.lineTextForBufferRow(2)).toBe("    if (items.length <= 1) return items;");
                expect(editor.lineTextForBufferRow(3)).toBe("    if (items.length <= 1) return items;");
                return expect(editor.getCursorBufferPosition()).toEqual([3, 13]);
              });
            });
          });
        });
      });
      describe(".indentSelectedRows()", function() {
        describe("when nothing is selected", function() {
          describe("when softTabs is enabled", function() {
            return it("indents line and retains selection", function() {
              editor.setSelectedBufferRange([[0, 3], [0, 3]]);
              editor.indentSelectedRows();
              expect(buffer.lineForRow(0)).toBe("  var quicksort = function () {");
              return expect(editor.getSelectedBufferRange()).toEqual([[0, 3 + editor.getTabLength()], [0, 3 + editor.getTabLength()]]);
            });
          });
          return describe("when softTabs is disabled", function() {
            return it("indents line and retains selection", function() {
              convertToHardTabs(buffer);
              editor.setSoftTabs(false);
              editor.setSelectedBufferRange([[0, 3], [0, 3]]);
              editor.indentSelectedRows();
              expect(buffer.lineForRow(0)).toBe("\tvar quicksort = function () {");
              return expect(editor.getSelectedBufferRange()).toEqual([[0, 3 + 1], [0, 3 + 1]]);
            });
          });
        });
        describe("when one line is selected", function() {
          describe("when softTabs is enabled", function() {
            return it("indents line and retains selection", function() {
              editor.setSelectedBufferRange([[0, 4], [0, 14]]);
              editor.indentSelectedRows();
              expect(buffer.lineForRow(0)).toBe((editor.getTabText()) + "var quicksort = function () {");
              return expect(editor.getSelectedBufferRange()).toEqual([[0, 4 + editor.getTabLength()], [0, 14 + editor.getTabLength()]]);
            });
          });
          return describe("when softTabs is disabled", function() {
            return it("indents line and retains selection", function() {
              convertToHardTabs(buffer);
              editor.setSoftTabs(false);
              editor.setSelectedBufferRange([[0, 4], [0, 14]]);
              editor.indentSelectedRows();
              expect(buffer.lineForRow(0)).toBe("\tvar quicksort = function () {");
              return expect(editor.getSelectedBufferRange()).toEqual([[0, 4 + 1], [0, 14 + 1]]);
            });
          });
        });
        return describe("when multiple lines are selected", function() {
          describe("when softTabs is enabled", function() {
            it("indents selected lines (that are not empty) and retains selection", function() {
              editor.setSelectedBufferRange([[9, 1], [11, 15]]);
              editor.indentSelectedRows();
              expect(buffer.lineForRow(9)).toBe("    };");
              expect(buffer.lineForRow(10)).toBe("");
              expect(buffer.lineForRow(11)).toBe("    return sort(Array.apply(this, arguments));");
              return expect(editor.getSelectedBufferRange()).toEqual([[9, 1 + editor.getTabLength()], [11, 15 + editor.getTabLength()]]);
            });
            return it("does not indent the last row if the selection ends at column 0", function() {
              editor.setSelectedBufferRange([[9, 1], [11, 0]]);
              editor.indentSelectedRows();
              expect(buffer.lineForRow(9)).toBe("    };");
              expect(buffer.lineForRow(10)).toBe("");
              expect(buffer.lineForRow(11)).toBe("  return sort(Array.apply(this, arguments));");
              return expect(editor.getSelectedBufferRange()).toEqual([[9, 1 + editor.getTabLength()], [11, 0]]);
            });
          });
          return describe("when softTabs is disabled", function() {
            return it("indents selected lines (that are not empty) and retains selection", function() {
              convertToHardTabs(buffer);
              editor.setSoftTabs(false);
              editor.setSelectedBufferRange([[9, 1], [11, 15]]);
              editor.indentSelectedRows();
              expect(buffer.lineForRow(9)).toBe("\t\t};");
              expect(buffer.lineForRow(10)).toBe("");
              expect(buffer.lineForRow(11)).toBe("\t\treturn sort(Array.apply(this, arguments));");
              return expect(editor.getSelectedBufferRange()).toEqual([[9, 1 + 1], [11, 15 + 1]]);
            });
          });
        });
      });
      describe(".outdentSelectedRows()", function() {
        describe("when nothing is selected", function() {
          it("outdents line and retains selection", function() {
            editor.setSelectedBufferRange([[1, 3], [1, 3]]);
            editor.outdentSelectedRows();
            expect(buffer.lineForRow(1)).toBe("var sort = function(items) {");
            return expect(editor.getSelectedBufferRange()).toEqual([[1, 3 - editor.getTabLength()], [1, 3 - editor.getTabLength()]]);
          });
          it("outdents when indent is less than a tab length", function() {
            editor.insertText(' ');
            editor.outdentSelectedRows();
            return expect(buffer.lineForRow(0)).toBe("var quicksort = function () {");
          });
          it("outdents a single hard tab when indent is multiple hard tabs and and the session is using soft tabs", function() {
            editor.insertText('\t\t');
            editor.outdentSelectedRows();
            expect(buffer.lineForRow(0)).toBe("\tvar quicksort = function () {");
            editor.outdentSelectedRows();
            return expect(buffer.lineForRow(0)).toBe("var quicksort = function () {");
          });
          it("outdents when a mix of hard tabs and soft tabs are used", function() {
            editor.insertText('\t   ');
            editor.outdentSelectedRows();
            expect(buffer.lineForRow(0)).toBe("   var quicksort = function () {");
            editor.outdentSelectedRows();
            expect(buffer.lineForRow(0)).toBe(" var quicksort = function () {");
            editor.outdentSelectedRows();
            return expect(buffer.lineForRow(0)).toBe("var quicksort = function () {");
          });
          return it("outdents only up to the first non-space non-tab character", function() {
            editor.insertText(' \tfoo\t ');
            editor.outdentSelectedRows();
            expect(buffer.lineForRow(0)).toBe("\tfoo\t var quicksort = function () {");
            editor.outdentSelectedRows();
            expect(buffer.lineForRow(0)).toBe("foo\t var quicksort = function () {");
            editor.outdentSelectedRows();
            return expect(buffer.lineForRow(0)).toBe("foo\t var quicksort = function () {");
          });
        });
        describe("when one line is selected", function() {
          return it("outdents line and retains editor", function() {
            editor.setSelectedBufferRange([[1, 4], [1, 14]]);
            editor.outdentSelectedRows();
            expect(buffer.lineForRow(1)).toBe("var sort = function(items) {");
            return expect(editor.getSelectedBufferRange()).toEqual([[1, 4 - editor.getTabLength()], [1, 14 - editor.getTabLength()]]);
          });
        });
        return describe("when multiple lines are selected", function() {
          it("outdents selected lines and retains editor", function() {
            editor.setSelectedBufferRange([[0, 1], [3, 15]]);
            editor.outdentSelectedRows();
            expect(buffer.lineForRow(0)).toBe("var quicksort = function () {");
            expect(buffer.lineForRow(1)).toBe("var sort = function(items) {");
            expect(buffer.lineForRow(2)).toBe("  if (items.length <= 1) return items;");
            expect(buffer.lineForRow(3)).toBe("  var pivot = items.shift(), current, left = [], right = [];");
            return expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [3, 15 - editor.getTabLength()]]);
          });
          return it("does not outdent the last line of the selection if it ends at column 0", function() {
            editor.setSelectedBufferRange([[0, 1], [3, 0]]);
            editor.outdentSelectedRows();
            expect(buffer.lineForRow(0)).toBe("var quicksort = function () {");
            expect(buffer.lineForRow(1)).toBe("var sort = function(items) {");
            expect(buffer.lineForRow(2)).toBe("  if (items.length <= 1) return items;");
            expect(buffer.lineForRow(3)).toBe("    var pivot = items.shift(), current, left = [], right = [];");
            return expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [3, 0]]);
          });
        });
      });
      describe(".autoIndentSelectedRows", function() {
        return it("auto-indents the selection", function() {
          editor.setCursorBufferPosition([2, 0]);
          editor.insertText("function() {\ninside=true\n}\n  i=1\n");
          editor.getLastSelection().setBufferRange([[2, 0], [6, 0]]);
          editor.autoIndentSelectedRows();
          expect(editor.lineTextForBufferRow(2)).toBe("    function() {");
          expect(editor.lineTextForBufferRow(3)).toBe("      inside=true");
          expect(editor.lineTextForBufferRow(4)).toBe("    }");
          return expect(editor.lineTextForBufferRow(5)).toBe("    i=1");
        });
      });
      describe(".toggleLineCommentsInSelection()", function() {
        it("toggles comments on the selected lines", function() {
          editor.setSelectedBufferRange([[4, 5], [7, 5]]);
          editor.toggleLineCommentsInSelection();
          expect(buffer.lineForRow(4)).toBe("    // while(items.length > 0) {");
          expect(buffer.lineForRow(5)).toBe("    //   current = items.shift();");
          expect(buffer.lineForRow(6)).toBe("    //   current < pivot ? left.push(current) : right.push(current);");
          expect(buffer.lineForRow(7)).toBe("    // }");
          expect(editor.getSelectedBufferRange()).toEqual([[4, 8], [7, 8]]);
          editor.toggleLineCommentsInSelection();
          expect(buffer.lineForRow(4)).toBe("    while(items.length > 0) {");
          expect(buffer.lineForRow(5)).toBe("      current = items.shift();");
          expect(buffer.lineForRow(6)).toBe("      current < pivot ? left.push(current) : right.push(current);");
          return expect(buffer.lineForRow(7)).toBe("    }");
        });
        it("does not comment the last line of a non-empty selection if it ends at column 0", function() {
          editor.setSelectedBufferRange([[4, 5], [7, 0]]);
          editor.toggleLineCommentsInSelection();
          expect(buffer.lineForRow(4)).toBe("    // while(items.length > 0) {");
          expect(buffer.lineForRow(5)).toBe("    //   current = items.shift();");
          expect(buffer.lineForRow(6)).toBe("    //   current < pivot ? left.push(current) : right.push(current);");
          return expect(buffer.lineForRow(7)).toBe("    }");
        });
        it("uncomments lines if all lines match the comment regex", function() {
          editor.setSelectedBufferRange([[0, 0], [0, 1]]);
          editor.toggleLineCommentsInSelection();
          expect(buffer.lineForRow(0)).toBe("// var quicksort = function () {");
          editor.setSelectedBufferRange([[0, 0], [2, Infinity]]);
          editor.toggleLineCommentsInSelection();
          expect(buffer.lineForRow(0)).toBe("// // var quicksort = function () {");
          expect(buffer.lineForRow(1)).toBe("//   var sort = function(items) {");
          expect(buffer.lineForRow(2)).toBe("//     if (items.length <= 1) return items;");
          editor.setSelectedBufferRange([[0, 0], [2, Infinity]]);
          editor.toggleLineCommentsInSelection();
          expect(buffer.lineForRow(0)).toBe("// var quicksort = function () {");
          expect(buffer.lineForRow(1)).toBe("  var sort = function(items) {");
          expect(buffer.lineForRow(2)).toBe("    if (items.length <= 1) return items;");
          editor.setSelectedBufferRange([[0, 0], [0, Infinity]]);
          editor.toggleLineCommentsInSelection();
          return expect(buffer.lineForRow(0)).toBe("var quicksort = function () {");
        });
        it("uncomments commented lines separated by an empty line", function() {
          editor.setSelectedBufferRange([[0, 0], [1, Infinity]]);
          editor.toggleLineCommentsInSelection();
          expect(buffer.lineForRow(0)).toBe("// var quicksort = function () {");
          expect(buffer.lineForRow(1)).toBe("//   var sort = function(items) {");
          buffer.insert([0, Infinity], '\n');
          editor.setSelectedBufferRange([[0, 0], [2, Infinity]]);
          editor.toggleLineCommentsInSelection();
          expect(buffer.lineForRow(0)).toBe("var quicksort = function () {");
          expect(buffer.lineForRow(1)).toBe("");
          return expect(buffer.lineForRow(2)).toBe("  var sort = function(items) {");
        });
        it("preserves selection emptiness", function() {
          editor.setCursorBufferPosition([4, 0]);
          editor.toggleLineCommentsInSelection();
          return expect(editor.getLastSelection().isEmpty()).toBeTruthy();
        });
        it("does not explode if the current language mode has no comment regex", function() {
          editor.destroy();
          waitsForPromise(function() {
            return atom.workspace.open(null, {
              autoIndent: false
            }).then(function(o) {
              return editor = o;
            });
          });
          return runs(function() {
            editor.setSelectedBufferRange([[4, 5], [4, 5]]);
            editor.toggleLineCommentsInSelection();
            return expect(buffer.lineForRow(4)).toBe("    while(items.length > 0) {");
          });
        });
        it("uncomments when the line lacks the trailing whitespace in the comment regex", function() {
          editor.setCursorBufferPosition([10, 0]);
          editor.toggleLineCommentsInSelection();
          expect(buffer.lineForRow(10)).toBe("// ");
          expect(editor.getSelectedBufferRange()).toEqual([[10, 3], [10, 3]]);
          editor.backspace();
          expect(buffer.lineForRow(10)).toBe("//");
          editor.toggleLineCommentsInSelection();
          expect(buffer.lineForRow(10)).toBe("");
          return expect(editor.getSelectedBufferRange()).toEqual([[10, 0], [10, 0]]);
        });
        return it("uncomments when the line has leading whitespace", function() {
          editor.setCursorBufferPosition([10, 0]);
          editor.toggleLineCommentsInSelection();
          expect(buffer.lineForRow(10)).toBe("// ");
          editor.moveToBeginningOfLine();
          editor.insertText("  ");
          editor.setSelectedBufferRange([[10, 0], [10, 0]]);
          editor.toggleLineCommentsInSelection();
          return expect(buffer.lineForRow(10)).toBe("  ");
        });
      });
      describe(".undo() and .redo()", function() {
        it("undoes/redoes the last change", function() {
          editor.insertText("foo");
          editor.undo();
          expect(buffer.lineForRow(0)).not.toContain("foo");
          editor.redo();
          return expect(buffer.lineForRow(0)).toContain("foo");
        });
        it("batches the undo / redo of changes caused by multiple cursors", function() {
          editor.setCursorScreenPosition([0, 0]);
          editor.addCursorAtScreenPosition([1, 0]);
          editor.insertText("foo");
          editor.backspace();
          expect(buffer.lineForRow(0)).toContain("fovar");
          expect(buffer.lineForRow(1)).toContain("fo ");
          editor.undo();
          expect(buffer.lineForRow(0)).toContain("foo");
          expect(buffer.lineForRow(1)).toContain("foo");
          editor.redo();
          expect(buffer.lineForRow(0)).not.toContain("foo");
          return expect(buffer.lineForRow(0)).toContain("fovar");
        });
        it("restores the selected ranges after undo and redo", function() {
          var selections;
          editor.setSelectedBufferRanges([[[1, 6], [1, 10]], [[1, 22], [1, 27]]]);
          editor["delete"]();
          editor["delete"]();
          selections = editor.getSelections();
          expect(buffer.lineForRow(1)).toBe('  var = function( {');
          expect(editor.getSelectedBufferRanges()).toEqual([[[1, 6], [1, 6]], [[1, 17], [1, 17]]]);
          editor.undo();
          expect(editor.getSelectedBufferRanges()).toEqual([[[1, 6], [1, 6]], [[1, 18], [1, 18]]]);
          editor.undo();
          expect(editor.getSelectedBufferRanges()).toEqual([[[1, 6], [1, 10]], [[1, 22], [1, 27]]]);
          editor.redo();
          return expect(editor.getSelectedBufferRanges()).toEqual([[[1, 6], [1, 6]], [[1, 18], [1, 18]]]);
        });
        return xit("restores folds after undo and redo", function() {
          editor.foldBufferRow(1);
          editor.setSelectedBufferRange([[1, 0], [10, Infinity]], {
            preserveFolds: true
          });
          expect(editor.isFoldedAtBufferRow(1)).toBeTruthy();
          editor.insertText("\  // testing\n  function foo() {\n    return 1 + 2;\n  }");
          expect(editor.isFoldedAtBufferRow(1)).toBeFalsy();
          editor.foldBufferRow(2);
          editor.undo();
          expect(editor.isFoldedAtBufferRow(1)).toBeTruthy();
          expect(editor.isFoldedAtBufferRow(9)).toBeTruthy();
          expect(editor.isFoldedAtBufferRow(10)).toBeFalsy();
          editor.redo();
          expect(editor.isFoldedAtBufferRow(1)).toBeFalsy();
          return expect(editor.isFoldedAtBufferRow(2)).toBeTruthy();
        });
      });
      describe("::transact", function() {
        return it("restores the selection when the transaction is undone/redone", function() {
          buffer.setText('1234');
          editor.setSelectedBufferRange([[0, 1], [0, 3]]);
          editor.transact(function() {
            editor["delete"]();
            editor.moveToEndOfLine();
            editor.insertText('5');
            return expect(buffer.getText()).toBe('145');
          });
          editor.undo();
          expect(buffer.getText()).toBe('1234');
          expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [0, 3]]);
          editor.redo();
          expect(buffer.getText()).toBe('145');
          return expect(editor.getSelectedBufferRange()).toEqual([[0, 3], [0, 3]]);
        });
      });
      return describe("when the buffer is changed (via its direct api, rather than via than edit session)", function() {
        it("moves the cursor so it is in the same relative position of the buffer", function() {
          var cursor1, cursor2, cursor3, ref1;
          expect(editor.getCursorScreenPosition()).toEqual([0, 0]);
          editor.addCursorAtScreenPosition([0, 5]);
          editor.addCursorAtScreenPosition([1, 0]);
          ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1], cursor3 = ref1[2];
          buffer.insert([0, 1], 'abc');
          expect(cursor1.getScreenPosition()).toEqual([0, 0]);
          expect(cursor2.getScreenPosition()).toEqual([0, 8]);
          return expect(cursor3.getScreenPosition()).toEqual([1, 0]);
        });
        it("does not destroy cursors or selections when a change encompasses them", function() {
          var cursor, selection;
          cursor = editor.getLastCursor();
          cursor.setBufferPosition([3, 3]);
          editor.buffer["delete"]([[3, 1], [3, 5]]);
          expect(cursor.getBufferPosition()).toEqual([3, 1]);
          expect(editor.getCursors().indexOf(cursor)).not.toBe(-1);
          selection = editor.getLastSelection();
          selection.setBufferRange([[3, 5], [3, 10]]);
          editor.buffer["delete"]([[3, 3], [3, 8]]);
          expect(selection.getBufferRange()).toEqual([[3, 3], [3, 5]]);
          return expect(editor.getSelections().indexOf(selection)).not.toBe(-1);
        });
        return it("merges cursors when the change causes them to overlap", function() {
          var cursor1, cursor2, cursor3, ref1;
          editor.setCursorScreenPosition([0, 0]);
          editor.addCursorAtScreenPosition([0, 2]);
          editor.addCursorAtScreenPosition([1, 2]);
          ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1], cursor3 = ref1[2];
          expect(editor.getCursors().length).toBe(3);
          buffer["delete"]([[0, 0], [0, 2]]);
          expect(editor.getCursors().length).toBe(2);
          expect(editor.getCursors()).toEqual([cursor1, cursor3]);
          expect(cursor1.getBufferPosition()).toEqual([0, 0]);
          return expect(cursor3.getBufferPosition()).toEqual([1, 2]);
        });
      });
    });
    describe('reading text', function() {
      return it('.lineTextForScreenRow(row)', function() {
        editor.foldBufferRow(4);
        expect(editor.lineTextForScreenRow(5)).toEqual('    return sort(left).concat(pivot).concat(sort(right));');
        return expect(editor.lineTextForScreenRow(100)).not.toBeDefined();
      });
    });
    describe(".deleteLine()", function() {
      it("deletes the first line when the cursor is there", function() {
        var count, line1;
        editor.getLastCursor().moveToTop();
        line1 = buffer.lineForRow(1);
        count = buffer.getLineCount();
        expect(buffer.lineForRow(0)).not.toBe(line1);
        editor.deleteLine();
        expect(buffer.lineForRow(0)).toBe(line1);
        return expect(buffer.getLineCount()).toBe(count - 1);
      });
      it("deletes the last line when the cursor is there", function() {
        var count, newCount, secondToLastLine;
        count = buffer.getLineCount();
        secondToLastLine = buffer.lineForRow(count - 2);
        expect(buffer.lineForRow(count - 1)).not.toBe(secondToLastLine);
        editor.getLastCursor().moveToBottom();
        editor.deleteLine();
        newCount = buffer.getLineCount();
        expect(buffer.lineForRow(newCount - 1)).toBe(secondToLastLine);
        return expect(newCount).toBe(count - 1);
      });
      it("deletes whole lines when partial lines are selected", function() {
        var count, line2;
        editor.setSelectedBufferRange([[0, 2], [1, 2]]);
        line2 = buffer.lineForRow(2);
        count = buffer.getLineCount();
        expect(buffer.lineForRow(0)).not.toBe(line2);
        expect(buffer.lineForRow(1)).not.toBe(line2);
        editor.deleteLine();
        expect(buffer.lineForRow(0)).toBe(line2);
        return expect(buffer.getLineCount()).toBe(count - 2);
      });
      it("deletes a line only once when multiple selections are on the same line", function() {
        var count, line1;
        line1 = buffer.lineForRow(1);
        count = buffer.getLineCount();
        editor.setSelectedBufferRanges([[[0, 1], [0, 2]], [[0, 4], [0, 5]]]);
        expect(buffer.lineForRow(0)).not.toBe(line1);
        editor.deleteLine();
        expect(buffer.lineForRow(0)).toBe(line1);
        return expect(buffer.getLineCount()).toBe(count - 1);
      });
      it("only deletes first line if only newline is selected on second line", function() {
        var count, line1;
        editor.setSelectedBufferRange([[0, 2], [1, 0]]);
        line1 = buffer.lineForRow(1);
        count = buffer.getLineCount();
        expect(buffer.lineForRow(0)).not.toBe(line1);
        editor.deleteLine();
        expect(buffer.lineForRow(0)).toBe(line1);
        return expect(buffer.getLineCount()).toBe(count - 1);
      });
      it("deletes the entire region when invoke on a folded region", function() {
        editor.foldBufferRow(1);
        editor.getLastCursor().moveToTop();
        editor.getLastCursor().moveDown();
        expect(buffer.getLineCount()).toBe(13);
        editor.deleteLine();
        return expect(buffer.getLineCount()).toBe(4);
      });
      it("deletes the entire file from the bottom up", function() {
        var count, i, line, ref1;
        count = buffer.getLineCount();
        expect(count).toBeGreaterThan(0);
        for (line = i = 0, ref1 = count; 0 <= ref1 ? i < ref1 : i > ref1; line = 0 <= ref1 ? ++i : --i) {
          editor.getLastCursor().moveToBottom();
          editor.deleteLine();
        }
        expect(buffer.getLineCount()).toBe(1);
        return expect(buffer.getText()).toBe('');
      });
      it("deletes the entire file from the top down", function() {
        var count, i, line, ref1;
        count = buffer.getLineCount();
        expect(count).toBeGreaterThan(0);
        for (line = i = 0, ref1 = count; 0 <= ref1 ? i < ref1 : i > ref1; line = 0 <= ref1 ? ++i : --i) {
          editor.getLastCursor().moveToTop();
          editor.deleteLine();
        }
        expect(buffer.getLineCount()).toBe(1);
        return expect(buffer.getText()).toBe('');
      });
      describe("when soft wrap is enabled", function() {
        return it("deletes the entire line that the cursor is on", function() {
          var count, line7;
          editor.setSoftWrapped(true);
          editor.setEditorWidthInChars(10);
          editor.setCursorBufferPosition([6]);
          line7 = buffer.lineForRow(7);
          count = buffer.getLineCount();
          expect(buffer.lineForRow(6)).not.toBe(line7);
          editor.deleteLine();
          expect(buffer.lineForRow(6)).toBe(line7);
          return expect(buffer.getLineCount()).toBe(count - 1);
        });
      });
      return describe("when the line being deleted preceeds a fold, and the command is undone", function() {
        return it("restores the line and preserves the fold", function() {
          editor.setCursorBufferPosition([4]);
          editor.foldCurrentRow();
          expect(editor.isFoldedAtScreenRow(4)).toBeTruthy();
          editor.setCursorBufferPosition([3]);
          editor.deleteLine();
          expect(editor.isFoldedAtScreenRow(3)).toBeTruthy();
          expect(buffer.lineForRow(3)).toBe('    while(items.length > 0) {');
          editor.undo();
          expect(editor.isFoldedAtScreenRow(4)).toBeTruthy();
          return expect(buffer.lineForRow(3)).toBe('    var pivot = items.shift(), current, left = [], right = [];');
        });
      });
    });
    describe(".replaceSelectedText(options, fn)", function() {
      describe("when no text is selected", function() {
        return it("inserts the text returned from the function at the cursor position", function() {
          editor.replaceSelectedText({}, function() {
            return '123';
          });
          expect(buffer.lineForRow(0)).toBe('123var quicksort = function () {');
          editor.replaceSelectedText({
            selectWordIfEmpty: true
          }, function() {
            return 'var';
          });
          editor.setCursorBufferPosition([0]);
          expect(buffer.lineForRow(0)).toBe('var quicksort = function () {');
          editor.setCursorBufferPosition([10]);
          editor.replaceSelectedText(null, function() {
            return '';
          });
          return expect(buffer.lineForRow(10)).toBe('');
        });
      });
      return describe("when text is selected", function() {
        return it("replaces the selected text with the text returned from the function", function() {
          editor.setSelectedBufferRange([[0, 1], [0, 3]]);
          editor.replaceSelectedText({}, function() {
            return 'ia';
          });
          return expect(buffer.lineForRow(0)).toBe('via quicksort = function () {');
        });
      });
    });
    describe(".transpose()", function() {
      it("swaps two characters", function() {
        editor.buffer.setText("abc");
        editor.setCursorScreenPosition([0, 1]);
        editor.transpose();
        return expect(editor.lineTextForBufferRow(0)).toBe('bac');
      });
      return it("reverses a selection", function() {
        editor.buffer.setText("xabcz");
        editor.setSelectedBufferRange([[0, 1], [0, 4]]);
        editor.transpose();
        return expect(editor.lineTextForBufferRow(0)).toBe('xcbaz');
      });
    });
    describe(".upperCase()", function() {
      describe("when there is no selection", function() {
        return it("upper cases the current word", function() {
          editor.buffer.setText("aBc");
          editor.setCursorScreenPosition([0, 1]);
          editor.upperCase();
          expect(editor.lineTextForBufferRow(0)).toBe('ABC');
          return expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [0, 1]]);
        });
      });
      return describe("when there is a selection", function() {
        return it("upper cases the current selection", function() {
          editor.buffer.setText("abc");
          editor.setSelectedBufferRange([[0, 0], [0, 2]]);
          editor.upperCase();
          expect(editor.lineTextForBufferRow(0)).toBe('ABc');
          return expect(editor.getSelectedBufferRange()).toEqual([[0, 0], [0, 2]]);
        });
      });
    });
    describe(".lowerCase()", function() {
      describe("when there is no selection", function() {
        return it("lower cases the current word", function() {
          editor.buffer.setText("aBC");
          editor.setCursorScreenPosition([0, 1]);
          editor.lowerCase();
          expect(editor.lineTextForBufferRow(0)).toBe('abc');
          return expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [0, 1]]);
        });
      });
      return describe("when there is a selection", function() {
        return it("lower cases the current selection", function() {
          editor.buffer.setText("ABC");
          editor.setSelectedBufferRange([[0, 0], [0, 2]]);
          editor.lowerCase();
          expect(editor.lineTextForBufferRow(0)).toBe('abC');
          return expect(editor.getSelectedBufferRange()).toEqual([[0, 0], [0, 2]]);
        });
      });
    });
    describe("soft-tabs detection", function() {
      return it("assigns soft / hard tabs based on the contents of the buffer, or uses the default if unknown", function() {
        waitsForPromise(function() {
          return atom.workspace.open('sample.js', {
            softTabs: false
          }).then(function(editor) {
            return expect(editor.getSoftTabs()).toBeTruthy();
          });
        });
        waitsForPromise(function() {
          return atom.workspace.open('sample-with-tabs.coffee', {
            softTabs: true
          }).then(function(editor) {
            return expect(editor.getSoftTabs()).toBeFalsy();
          });
        });
        waitsForPromise(function() {
          return atom.workspace.open('sample-with-tabs-and-initial-comment.js', {
            softTabs: true
          }).then(function(editor) {
            return expect(editor.getSoftTabs()).toBeFalsy();
          });
        });
        return waitsForPromise(function() {
          return atom.workspace.open(null, {
            softTabs: false
          }).then(function(editor) {
            return expect(editor.getSoftTabs()).toBeFalsy();
          });
        });
      });
    });
    describe('.getTabLength()', function() {
      return describe('when scoped settings are used', function() {
        var coffeeEditor;
        coffeeEditor = null;
        beforeEach(function() {
          waitsForPromise(function() {
            return atom.packages.activatePackage('language-coffee-script');
          });
          return waitsForPromise(function() {
            return atom.project.open('coffee.coffee', {
              autoIndent: false
            }).then(function(o) {
              return coffeeEditor = o;
            });
          });
        });
        ({
          afterEach: function() {
            atom.packages.deactivatePackages();
            return atom.packages.unloadPackages();
          }
        });
        it('returns correct values based on the scope of the set grammars', function() {
          atom.config.set('editor.tabLength', 6, {
            scopeSelector: '.source.coffee'
          });
          expect(editor.getTabLength()).toBe(2);
          return expect(coffeeEditor.getTabLength()).toBe(6);
        });
        it('retokenizes when the tab length is updated via .setTabLength()', function() {
          var changeHandler;
          expect(editor.getTabLength()).toBe(2);
          expect(editor.tokenizedLineForScreenRow(5).tokens[0].firstNonWhitespaceIndex).toBe(2);
          editor.setTabLength(6);
          expect(editor.getTabLength()).toBe(6);
          expect(editor.tokenizedLineForScreenRow(5).tokens[0].firstNonWhitespaceIndex).toBe(6);
          changeHandler = jasmine.createSpy('changeHandler');
          editor.onDidChange(changeHandler);
          editor.setTabLength(6);
          return expect(changeHandler).not.toHaveBeenCalled();
        });
        it('retokenizes when the editor.tabLength setting is updated', function() {
          expect(editor.getTabLength()).toBe(2);
          expect(editor.tokenizedLineForScreenRow(5).tokens[0].firstNonWhitespaceIndex).toBe(2);
          atom.config.set('editor.tabLength', 6, {
            scopeSelector: '.source.js'
          });
          expect(editor.getTabLength()).toBe(6);
          return expect(editor.tokenizedLineForScreenRow(5).tokens[0].firstNonWhitespaceIndex).toBe(6);
        });
        return it('updates the tab length when the grammar changes', function() {
          atom.config.set('editor.tabLength', 6, {
            scopeSelector: '.source.coffee'
          });
          expect(editor.getTabLength()).toBe(2);
          expect(editor.tokenizedLineForScreenRow(5).tokens[0].firstNonWhitespaceIndex).toBe(2);
          editor.setGrammar(coffeeEditor.getGrammar());
          expect(editor.getTabLength()).toBe(6);
          return expect(editor.tokenizedLineForScreenRow(5).tokens[0].firstNonWhitespaceIndex).toBe(6);
        });
      });
    });
    describe(".indentLevelForLine(line)", function() {
      it("returns the indent level when the line has only leading whitespace", function() {
        expect(editor.indentLevelForLine("    hello")).toBe(2);
        return expect(editor.indentLevelForLine("   hello")).toBe(1.5);
      });
      it("returns the indent level when the line has only leading tabs", function() {
        return expect(editor.indentLevelForLine("\t\thello")).toBe(2);
      });
      return it("returns the indent level based on the character starting the line when the leading whitespace contains both spaces and tabs", function() {
        expect(editor.indentLevelForLine("\t  hello")).toBe(2);
        expect(editor.indentLevelForLine("  \thello")).toBe(2);
        expect(editor.indentLevelForLine("  \t hello")).toBe(2.5);
        expect(editor.indentLevelForLine("    \t \thello")).toBe(4);
        expect(editor.indentLevelForLine("     \t \thello")).toBe(4);
        return expect(editor.indentLevelForLine("     \t \t hello")).toBe(4.5);
      });
    });
    describe("when the buffer is reloaded", function() {
      return it("preserves the current cursor position", function() {
        editor.setCursorScreenPosition([0, 1]);
        editor.buffer.reload();
        return expect(editor.getCursorScreenPosition()).toEqual([0, 1]);
      });
    });
    describe("when a better-matched grammar is added to syntax", function() {
      return it("switches to the better-matched grammar and re-tokenizes the buffer", function() {
        var jsGrammar;
        editor.destroy();
        jsGrammar = atom.grammars.selectGrammar('a.js');
        atom.grammars.removeGrammar(jsGrammar);
        waitsForPromise(function() {
          return atom.workspace.open('sample.js', {
            autoIndent: false
          }).then(function(o) {
            return editor = o;
          });
        });
        return runs(function() {
          expect(editor.getGrammar()).toBe(atom.grammars.nullGrammar);
          expect(editor.tokenizedLineForScreenRow(0).tokens.length).toBe(1);
          atom.grammars.addGrammar(jsGrammar);
          expect(editor.getGrammar()).toBe(jsGrammar);
          return expect(editor.tokenizedLineForScreenRow(0).tokens.length).toBeGreaterThan(1);
        });
      });
    });
    describe("editor.autoIndent", function() {
      describe("when editor.autoIndent is false (default)", function() {
        return describe("when `indent` is triggered", function() {
          return it("does not auto-indent the line", function() {
            editor.setCursorBufferPosition([1, 30]);
            editor.insertText("\n ");
            expect(editor.lineTextForBufferRow(2)).toBe(" ");
            atom.config.set("editor.autoIndent", false);
            editor.indent();
            return expect(editor.lineTextForBufferRow(2)).toBe("  ");
          });
        });
      });
      describe("when editor.autoIndent is true", function() {
        beforeEach(function() {
          return atom.config.set("editor.autoIndent", true);
        });
        describe("when `indent` is triggered", function() {
          return it("auto-indents the line", function() {
            editor.setCursorBufferPosition([1, 30]);
            editor.insertText("\n ");
            expect(editor.lineTextForBufferRow(2)).toBe(" ");
            atom.config.set("editor.autoIndent", true);
            editor.indent();
            return expect(editor.lineTextForBufferRow(2)).toBe("    ");
          });
        });
        describe("when a newline is added", function() {
          describe("when the line preceding the newline adds a new level of indentation", function() {
            return it("indents the newline to one additional level of indentation beyond the preceding line", function() {
              editor.setCursorBufferPosition([1, Infinity]);
              editor.insertText('\n');
              return expect(editor.indentationForBufferRow(2)).toBe(editor.indentationForBufferRow(1) + 1);
            });
          });
          describe("when the line preceding the newline does't add a level of indentation", function() {
            return it("indents the new line to the same level a as the preceding line", function() {
              editor.setCursorBufferPosition([5, 14]);
              editor.insertText('\n');
              return expect(editor.indentationForBufferRow(6)).toBe(editor.indentationForBufferRow(5));
            });
          });
          describe("when the line preceding the newline is a comment", function() {
            return it("maintains the indent of the commented line", function() {
              editor.setCursorBufferPosition([0, 0]);
              editor.insertText('    //');
              editor.setCursorBufferPosition([0, Infinity]);
              editor.insertText('\n');
              return expect(editor.indentationForBufferRow(1)).toBe(2);
            });
          });
          describe("when the line preceding the newline contains only whitespace", function() {
            return it("bases the new line's indentation on only the preceding line", function() {
              editor.setCursorBufferPosition([6, Infinity]);
              editor.insertText("\n  ");
              expect(editor.getCursorBufferPosition()).toEqual([7, 2]);
              editor.insertNewline();
              return expect(editor.lineTextForBufferRow(8)).toBe("  ");
            });
          });
          it("does not indent the line preceding the newline", function() {
            editor.setCursorBufferPosition([2, 0]);
            editor.insertText('  var this-line-should-be-indented-more\n');
            expect(editor.indentationForBufferRow(1)).toBe(1);
            atom.config.set("editor.autoIndent", true);
            editor.setCursorBufferPosition([2, Infinity]);
            editor.insertText('\n');
            expect(editor.indentationForBufferRow(1)).toBe(1);
            return expect(editor.indentationForBufferRow(2)).toBe(1);
          });
          return describe("when the cursor is before whitespace", function() {
            return it("retains the whitespace following the cursor on the new line", function() {
              editor.setText("  var sort = function() {}");
              editor.setCursorScreenPosition([0, 12]);
              editor.insertNewline();
              expect(buffer.lineForRow(0)).toBe('  var sort =');
              expect(buffer.lineForRow(1)).toBe('   function() {}');
              return expect(editor.getCursorScreenPosition()).toEqual([1, 2]);
            });
          });
        });
        describe("when inserted text matches a decrease indent pattern", function() {
          describe("when the preceding line matches an increase indent pattern", function() {
            return it("decreases the indentation to match that of the preceding line", function() {
              editor.setCursorBufferPosition([1, Infinity]);
              editor.insertText('\n');
              expect(editor.indentationForBufferRow(2)).toBe(editor.indentationForBufferRow(1) + 1);
              editor.insertText('}');
              return expect(editor.indentationForBufferRow(2)).toBe(editor.indentationForBufferRow(1));
            });
          });
          return describe("when the preceding line doesn't match an increase indent pattern", function() {
            it("decreases the indentation to be one level below that of the preceding line", function() {
              editor.setCursorBufferPosition([3, Infinity]);
              editor.insertText('\n    ');
              expect(editor.indentationForBufferRow(4)).toBe(editor.indentationForBufferRow(3));
              editor.insertText('}');
              return expect(editor.indentationForBufferRow(4)).toBe(editor.indentationForBufferRow(3) - 1);
            });
            return it("doesn't break when decreasing the indentation on a row that has no indentation", function() {
              editor.setCursorBufferPosition([12, Infinity]);
              editor.insertText("\n}; # too many closing brackets!");
              return expect(editor.lineTextForBufferRow(13)).toBe("}; # too many closing brackets!");
            });
          });
        });
        describe("when inserted text does not match a decrease indent pattern", function() {
          return it("does not decrease the indentation", function() {
            editor.setCursorBufferPosition([12, 0]);
            editor.insertText('  ');
            expect(editor.lineTextForBufferRow(12)).toBe('  };');
            editor.insertText('\t\t');
            return expect(editor.lineTextForBufferRow(12)).toBe('  \t\t};');
          });
        });
        return describe("when the current line does not match a decrease indent pattern", function() {
          return it("leaves the line unchanged", function() {
            editor.setCursorBufferPosition([2, 4]);
            expect(editor.indentationForBufferRow(2)).toBe(editor.indentationForBufferRow(1) + 1);
            editor.insertText('foo');
            return expect(editor.indentationForBufferRow(2)).toBe(editor.indentationForBufferRow(1) + 1);
          });
        });
      });
      return describe('when scoped settings are used', function() {
        var coffeeEditor;
        coffeeEditor = null;
        beforeEach(function() {
          waitsForPromise(function() {
            return atom.packages.activatePackage('language-coffee-script');
          });
          waitsForPromise(function() {
            return atom.project.open('coffee.coffee', {
              autoIndent: false
            }).then(function(o) {
              return coffeeEditor = o;
            });
          });
          return runs(function() {
            atom.config.set('editor.autoIndent', true, {
              scopeSelector: '.source.js'
            });
            return atom.config.set('editor.autoIndent', false, {
              scopeSelector: '.source.coffee'
            });
          });
        });
        ({
          afterEach: function() {
            atom.packages.deactivatePackages();
            return atom.packages.unloadPackages();
          }
        });
        return it("does not auto-indent the line for javascript files", function() {
          editor.setCursorBufferPosition([1, 30]);
          editor.insertText("\n");
          expect(editor.lineTextForBufferRow(2)).toBe("    ");
          coffeeEditor.setCursorBufferPosition([1, 18]);
          coffeeEditor.insertText("\n");
          return expect(coffeeEditor.lineTextForBufferRow(2)).toBe("");
        });
      });
    });
    describe("soft and hard tabs", function() {
      afterEach(function() {
        atom.packages.deactivatePackages();
        return atom.packages.unloadPackages();
      });
      it("resets the tab style when tokenization is complete", function() {
        editor.destroy();
        waitsForPromise(function() {
          return atom.project.open('sample-with-tabs-and-leading-comment.coffee').then(function(o) {
            return editor = o;
          });
        });
        runs(function() {
          return expect(editor.softTabs).toBe(true);
        });
        waitsForPromise(function() {
          return atom.packages.activatePackage('language-coffee-script');
        });
        return runs(function() {
          return expect(editor.softTabs).toBe(false);
        });
      });
      return it("uses hard tabs in Makefile files", function() {
        waitsForPromise(function() {
          return atom.packages.activatePackage('language-make');
        });
        waitsForPromise(function() {
          return atom.project.open('Makefile').then(function(o) {
            return editor = o;
          });
        });
        return runs(function() {
          return expect(editor.softTabs).toBe(false);
        });
      });
    });
    describe(".destroy()", function() {
      it("destroys all markers associated with the edit session", function() {
        editor.foldAll();
        expect(buffer.getMarkerCount()).toBeGreaterThan(0);
        editor.destroy();
        return expect(buffer.getMarkerCount()).toBe(0);
      });
      return it("notifies ::onDidDestroy observers when the editor is destroyed", function() {
        var destroyObserverCalled;
        destroyObserverCalled = false;
        editor.onDidDestroy(function() {
          return destroyObserverCalled = true;
        });
        editor.destroy();
        return expect(destroyObserverCalled).toBe(true);
      });
    });
    describe(".joinLines()", function() {
      describe("when no text is selected", function() {
        describe("when the line below isn't empty", function() {
          return it("joins the line below with the current line separated by a space and moves the cursor to the start of line that was moved up", function() {
            editor.setCursorBufferPosition([0, Infinity]);
            editor.insertText('  ');
            editor.setCursorBufferPosition([0]);
            editor.joinLines();
            expect(editor.lineTextForBufferRow(0)).toBe('var quicksort = function () { var sort = function(items) {');
            return expect(editor.getCursorBufferPosition()).toEqual([0, 29]);
          });
        });
        describe("when the line below is empty", function() {
          return it("deletes the line below and moves the cursor to the end of the line", function() {
            editor.setCursorBufferPosition([9]);
            editor.joinLines();
            expect(editor.lineTextForBufferRow(9)).toBe('  };');
            expect(editor.lineTextForBufferRow(10)).toBe('  return sort(Array.apply(this, arguments));');
            return expect(editor.getCursorBufferPosition()).toEqual([9, 4]);
          });
        });
        describe("when the cursor is on the last row", function() {
          return it("does nothing", function() {
            editor.setCursorBufferPosition([Infinity, Infinity]);
            editor.joinLines();
            return expect(editor.lineTextForBufferRow(12)).toBe('};');
          });
        });
        return describe("when the line is empty", function() {
          return it("joins the line below with the current line with no added space", function() {
            editor.setCursorBufferPosition([10]);
            editor.joinLines();
            expect(editor.lineTextForBufferRow(10)).toBe('return sort(Array.apply(this, arguments));');
            return expect(editor.getCursorBufferPosition()).toEqual([10, 0]);
          });
        });
      });
      return describe("when text is selected", function() {
        describe("when the selection does not span multiple lines", function() {
          return it("joins the line below with the current line separated by a space and retains the selected text", function() {
            editor.setSelectedBufferRange([[0, 1], [0, 3]]);
            editor.joinLines();
            expect(editor.lineTextForBufferRow(0)).toBe('var quicksort = function () { var sort = function(items) {');
            return expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [0, 3]]);
          });
        });
        return describe("when the selection spans multiple lines", function() {
          return it("joins all selected lines separated by a space and retains the selected text", function() {
            editor.setSelectedBufferRange([[9, 3], [12, 1]]);
            editor.joinLines();
            expect(editor.lineTextForBufferRow(9)).toBe('  }; return sort(Array.apply(this, arguments)); };');
            return expect(editor.getSelectedBufferRange()).toEqual([[9, 3], [9, 49]]);
          });
        });
      });
    });
    describe(".duplicateLines()", function() {
      it("for each selection, duplicates all buffer lines intersected by the selection", function() {
        editor.foldBufferRow(4);
        editor.setCursorBufferPosition([2, 5]);
        editor.addSelectionForBufferRange([[3, 0], [8, 0]], {
          preserveFolds: true
        });
        editor.duplicateLines();
        expect(editor.getTextInBufferRange([[2, 0], [13, 5]])).toBe("\    if (items.length <= 1) return items;\n    if (items.length <= 1) return items;\n    var pivot = items.shift(), current, left = [], right = [];\n    while(items.length > 0) {\n      current = items.shift();\n      current < pivot ? left.push(current) : right.push(current);\n    }\n    var pivot = items.shift(), current, left = [], right = [];\n    while(items.length > 0) {\n      current = items.shift();\n      current < pivot ? left.push(current) : right.push(current);\n    }");
        expect(editor.getSelectedBufferRanges()).toEqual([[[3, 5], [3, 5]], [[9, 0], [14, 0]]]);
        expect(editor.tokenizedLineForScreenRow(5).fold).toBeDefined();
        expect(editor.tokenizedLineForScreenRow(7).fold).toBeDefined();
        expect(editor.tokenizedLineForScreenRow(7).text).toBe("    while(items.length > 0) {");
        return expect(editor.tokenizedLineForScreenRow(8).text).toBe("    return sort(left).concat(pivot).concat(sort(right));");
      });
      it("duplicates all folded lines for empty selections on folded lines", function() {
        editor.foldBufferRow(4);
        editor.setCursorBufferPosition([4, 0]);
        editor.duplicateLines();
        expect(editor.getTextInBufferRange([[2, 0], [11, 5]])).toBe("\    if (items.length <= 1) return items;\n    var pivot = items.shift(), current, left = [], right = [];\n    while(items.length > 0) {\n      current = items.shift();\n      current < pivot ? left.push(current) : right.push(current);\n    }\n    while(items.length > 0) {\n      current = items.shift();\n      current < pivot ? left.push(current) : right.push(current);\n    }");
        return expect(editor.getSelectedBufferRange()).toEqual([[8, 0], [8, 0]]);
      });
      return it("can duplicate the last line of the buffer", function() {
        editor.setSelectedBufferRange([[11, 0], [12, 2]]);
        editor.duplicateLines();
        expect(editor.getTextInBufferRange([[11, 0], [14, 2]])).toBe("\  return sort(Array.apply(this, arguments));\n};\n  return sort(Array.apply(this, arguments));\n};");
        return expect(editor.getSelectedBufferRange()).toEqual([[13, 0], [14, 2]]);
      });
    });
    describe(".shouldPromptToSave()", function() {
      return it("returns false when an edit session's buffer is in use by more than one session", function() {
        var editor2;
        jasmine.unspy(editor, 'shouldPromptToSave');
        expect(editor.shouldPromptToSave()).toBeFalsy();
        buffer.setText('changed');
        expect(editor.shouldPromptToSave()).toBeTruthy();
        editor2 = null;
        waitsForPromise(function() {
          return atom.project.open('sample.js', {
            autoIndent: false
          }).then(function(o) {
            return editor2 = o;
          });
        });
        return runs(function() {
          expect(editor.shouldPromptToSave()).toBeFalsy();
          editor2.destroy();
          return expect(editor.shouldPromptToSave()).toBeTruthy();
        });
      });
    });
    describe("when the editor contains surrogate pair characters", function() {
      it("correctly backspaces over them", function() {
        editor.setText('\uD835\uDF97\uD835\uDF97\uD835\uDF97');
        editor.moveToBottom();
        editor.backspace();
        expect(editor.getText()).toBe('\uD835\uDF97\uD835\uDF97');
        editor.backspace();
        expect(editor.getText()).toBe('\uD835\uDF97');
        editor.backspace();
        return expect(editor.getText()).toBe('');
      });
      it("correctly deletes over them", function() {
        editor.setText('\uD835\uDF97\uD835\uDF97\uD835\uDF97');
        editor.moveToTop();
        editor["delete"]();
        expect(editor.getText()).toBe('\uD835\uDF97\uD835\uDF97');
        editor["delete"]();
        expect(editor.getText()).toBe('\uD835\uDF97');
        editor["delete"]();
        return expect(editor.getText()).toBe('');
      });
      return it("correctly moves over them", function() {
        editor.setText('\uD835\uDF97\uD835\uDF97\uD835\uDF97\n');
        editor.moveToTop();
        editor.moveRight();
        expect(editor.getCursorBufferPosition()).toEqual([0, 2]);
        editor.moveRight();
        expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
        editor.moveRight();
        expect(editor.getCursorBufferPosition()).toEqual([0, 6]);
        editor.moveRight();
        expect(editor.getCursorBufferPosition()).toEqual([1, 0]);
        editor.moveLeft();
        expect(editor.getCursorBufferPosition()).toEqual([0, 6]);
        editor.moveLeft();
        expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
        editor.moveLeft();
        expect(editor.getCursorBufferPosition()).toEqual([0, 2]);
        editor.moveLeft();
        return expect(editor.getCursorBufferPosition()).toEqual([0, 0]);
      });
    });
    describe("when the editor contains variation sequence character pairs", function() {
      it("correctly backspaces over them", function() {
        editor.setText('\u2714\uFE0E\u2714\uFE0E\u2714\uFE0E');
        editor.moveToBottom();
        editor.backspace();
        expect(editor.getText()).toBe('\u2714\uFE0E\u2714\uFE0E');
        editor.backspace();
        expect(editor.getText()).toBe('\u2714\uFE0E');
        editor.backspace();
        return expect(editor.getText()).toBe('');
      });
      it("correctly deletes over them", function() {
        editor.setText('\u2714\uFE0E\u2714\uFE0E\u2714\uFE0E');
        editor.moveToTop();
        editor["delete"]();
        expect(editor.getText()).toBe('\u2714\uFE0E\u2714\uFE0E');
        editor["delete"]();
        expect(editor.getText()).toBe('\u2714\uFE0E');
        editor["delete"]();
        return expect(editor.getText()).toBe('');
      });
      return it("correctly moves over them", function() {
        editor.setText('\u2714\uFE0E\u2714\uFE0E\u2714\uFE0E\n');
        editor.moveToTop();
        editor.moveRight();
        expect(editor.getCursorBufferPosition()).toEqual([0, 2]);
        editor.moveRight();
        expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
        editor.moveRight();
        expect(editor.getCursorBufferPosition()).toEqual([0, 6]);
        editor.moveRight();
        expect(editor.getCursorBufferPosition()).toEqual([1, 0]);
        editor.moveLeft();
        expect(editor.getCursorBufferPosition()).toEqual([0, 6]);
        editor.moveLeft();
        expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
        editor.moveLeft();
        expect(editor.getCursorBufferPosition()).toEqual([0, 2]);
        editor.moveLeft();
        return expect(editor.getCursorBufferPosition()).toEqual([0, 0]);
      });
    });
    describe(".setIndentationForBufferRow", function() {
      describe("when the editor uses soft tabs but the row has hard tabs", function() {
        return it("only replaces whitespace characters", function() {
          editor.setSoftWrapped(true);
          editor.setText("\t1\n\t2");
          editor.setCursorBufferPosition([0, 0]);
          editor.setIndentationForBufferRow(0, 2);
          return expect(editor.getText()).toBe("    1\n\t2");
        });
      });
      return describe("when the indentation level is a non-integer", function() {
        return it("does not throw an exception", function() {
          editor.setSoftWrapped(true);
          editor.setText("\t1\n\t2");
          editor.setCursorBufferPosition([0, 0]);
          editor.setIndentationForBufferRow(0, 2.1);
          return expect(editor.getText()).toBe("    1\n\t2");
        });
      });
    });
    describe(".reloadGrammar()", function() {
      beforeEach(function() {
        return waitsForPromise(function() {
          return atom.packages.activatePackage('language-coffee-script');
        });
      });
      return it("updates the grammar based on grammar overrides", function() {
        var callback;
        expect(editor.getGrammar().name).toBe('JavaScript');
        atom.grammars.setGrammarOverrideForPath(editor.getPath(), 'source.coffee');
        callback = jasmine.createSpy('callback');
        editor.onDidChangeGrammar(callback);
        editor.reloadGrammar();
        expect(editor.getGrammar().name).toBe('CoffeeScript');
        expect(callback.callCount).toBe(1);
        return expect(callback.argsForCall[0][0]).toBe(atom.grammars.grammarForScopeName('source.coffee'));
      });
    });
    describe("when the editor's grammar has an injection selector", function() {
      beforeEach(function() {
        waitsForPromise(function() {
          return atom.packages.activatePackage('language-text');
        });
        return waitsForPromise(function() {
          return atom.packages.activatePackage('language-javascript');
        });
      });
      it("includes the grammar's patterns when the selector matches the current scope in other grammars", function() {
        waitsForPromise(function() {
          return atom.packages.activatePackage('language-hyperlink');
        });
        return runs(function() {
          var grammar, line, ref1, tags, tokens;
          grammar = atom.grammars.selectGrammar("text.js");
          ref1 = grammar.tokenizeLine("var i; // http://github.com"), line = ref1.line, tags = ref1.tags;
          tokens = atom.grammars.decodeTokens(line, tags);
          expect(tokens[0].value).toBe("var");
          expect(tokens[0].scopes).toEqual(["source.js", "storage.modifier.js"]);
          expect(tokens[6].value).toBe("http://github.com");
          return expect(tokens[6].scopes).toEqual(["source.js", "comment.line.double-slash.js", "markup.underline.link.http.hyperlink"]);
        });
      });
      return describe("when the grammar is added", function() {
        it("retokenizes existing buffers that contain tokens that match the injection selector", function() {
          waitsForPromise(function() {
            return atom.workspace.open('sample.js').then(function(o) {
              return editor = o;
            });
          });
          runs(function() {
            var tokens;
            editor.setText("// http://github.com");
            tokens = editor.tokenizedLineForScreenRow(0).tokens;
            expect(tokens[1].value).toBe(" http://github.com");
            return expect(tokens[1].scopes).toEqual(["source.js", "comment.line.double-slash.js"]);
          });
          waitsForPromise(function() {
            return atom.packages.activatePackage('language-hyperlink');
          });
          return runs(function() {
            var tokens;
            tokens = editor.tokenizedLineForScreenRow(0).tokens;
            expect(tokens[2].value).toBe("http://github.com");
            return expect(tokens[2].scopes).toEqual(["source.js", "comment.line.double-slash.js", "markup.underline.link.http.hyperlink"]);
          });
        });
        return describe("when the grammar is updated", function() {
          return it("retokenizes existing buffers that contain tokens that match the injection selector", function() {
            waitsForPromise(function() {
              return atom.workspace.open('sample.js').then(function(o) {
                return editor = o;
              });
            });
            runs(function() {
              var tokens;
              editor.setText("// SELECT * FROM OCTOCATS");
              tokens = editor.tokenizedLineForScreenRow(0).tokens;
              expect(tokens[1].value).toBe(" SELECT * FROM OCTOCATS");
              return expect(tokens[1].scopes).toEqual(["source.js", "comment.line.double-slash.js"]);
            });
            waitsForPromise(function() {
              return atom.packages.activatePackage('package-with-injection-selector');
            });
            runs(function() {
              var tokens;
              tokens = editor.tokenizedLineForScreenRow(0).tokens;
              expect(tokens[1].value).toBe(" SELECT * FROM OCTOCATS");
              return expect(tokens[1].scopes).toEqual(["source.js", "comment.line.double-slash.js"]);
            });
            waitsForPromise(function() {
              return atom.packages.activatePackage('language-sql');
            });
            return runs(function() {
              var tokens;
              tokens = editor.tokenizedLineForScreenRow(0).tokens;
              expect(tokens[2].value).toBe("SELECT");
              return expect(tokens[2].scopes).toEqual(["source.js", "comment.line.double-slash.js", "keyword.other.DML.sql"]);
            });
          });
        });
      });
    });
    describe(".normalizeTabsInBufferRange()", function() {
      return it("normalizes tabs depending on the editor's soft tab/tab length settings", function() {
        editor.setTabLength(1);
        editor.setSoftTabs(true);
        editor.setText('\t\t\t');
        editor.normalizeTabsInBufferRange([[0, 0], [0, 1]]);
        expect(editor.getText()).toBe(' \t\t');
        editor.setTabLength(2);
        editor.normalizeTabsInBufferRange([[0, 0], [Infinity, Infinity]]);
        expect(editor.getText()).toBe('     ');
        editor.setSoftTabs(false);
        editor.normalizeTabsInBufferRange([[0, 0], [Infinity, Infinity]]);
        return expect(editor.getText()).toBe('     ');
      });
    });
    describe(".scrollToCursorPosition()", function() {
      return it("scrolls the last cursor into view, centering around the cursor if possible and the 'center' option isn't false", function() {
        editor.setCursorScreenPosition([8, 8]);
        editor.setLineHeightInPixels(10);
        editor.setDefaultCharWidth(10);
        editor.setHeight(60);
        editor.setWidth(130);
        editor.setHorizontalScrollbarHeight(0);
        expect(editor.getScrollTop()).toBe(0);
        expect(editor.getScrollLeft()).toBe(0);
        editor.scrollToCursorPosition();
        expect(editor.getScrollTop()).toBe((8.5 * 10) - 30);
        expect(editor.getScrollBottom()).toBe((8.5 * 10) + 30);
        expect(editor.getScrollRight()).toBe((9 + editor.getHorizontalScrollMargin()) * 10);
        editor.setScrollTop(0);
        editor.scrollToCursorPosition({
          center: false
        });
        return expect(editor.getScrollBottom()).toBe((9 + editor.getVerticalScrollMargin()) * 10);
      });
    });
    describe(".pageUp/Down()", function() {
      return it("scrolls one screen height up or down and moves the cursor one page length", function() {
        editor.setLineHeightInPixels(10);
        editor.setHeight(50);
        expect(editor.getScrollHeight()).toBe(130);
        expect(editor.getCursorBufferPosition().row).toBe(0);
        editor.pageDown();
        expect(editor.getScrollTop()).toBe(50);
        expect(editor.getCursorBufferPosition().row).toBe(5);
        editor.pageDown();
        expect(editor.getScrollTop()).toBe(80);
        expect(editor.getCursorBufferPosition().row).toBe(10);
        editor.pageUp();
        expect(editor.getScrollTop()).toBe(30);
        expect(editor.getCursorBufferPosition().row).toBe(5);
        editor.pageUp();
        expect(editor.getScrollTop()).toBe(0);
        return expect(editor.getCursorBufferPosition().row).toBe(0);
      });
    });
    describe(".selectPageUp/Down()", function() {
      return it("selects one screen height of text up or down", function() {
        editor.setLineHeightInPixels(10);
        editor.setHeight(50);
        expect(editor.getScrollHeight()).toBe(130);
        expect(editor.getCursorBufferPosition().row).toBe(0);
        editor.selectPageDown();
        expect(editor.getScrollTop()).toBe(30);
        expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [5, 0]]]);
        editor.selectPageDown();
        expect(editor.getScrollTop()).toBe(80);
        expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [10, 0]]]);
        editor.selectPageDown();
        expect(editor.getScrollTop()).toBe(80);
        expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [12, 2]]]);
        editor.moveToBottom();
        editor.selectPageUp();
        expect(editor.getScrollTop()).toBe(50);
        expect(editor.getSelectedBufferRanges()).toEqual([[[7, 0], [12, 2]]]);
        editor.selectPageUp();
        expect(editor.getScrollTop()).toBe(0);
        expect(editor.getSelectedBufferRanges()).toEqual([[[2, 0], [12, 2]]]);
        editor.selectPageUp();
        expect(editor.getScrollTop()).toBe(0);
        return expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [12, 2]]]);
      });
    });
    describe('.get/setPlaceholderText()', function() {
      it('can be created with placeholderText', function() {
        var TextBuffer, newEditor;
        TextBuffer = require('text-buffer');
        newEditor = new TextEditor({
          buffer: new TextBuffer,
          mini: true,
          placeholderText: 'yep'
        });
        return expect(newEditor.getPlaceholderText()).toBe('yep');
      });
      return it('models placeholderText and emits an event when changed', function() {
        var handler;
        editor.onDidChangePlaceholderText(handler = jasmine.createSpy());
        expect(editor.getPlaceholderText()).toBeUndefined();
        editor.setPlaceholderText('OK');
        expect(handler).toHaveBeenCalledWith('OK');
        return expect(editor.getPlaceholderText()).toBe('OK');
      });
    });
    describe(".checkoutHeadRevision()", function() {
      it("reverts to the version of its file checked into the project repository", function() {
        atom.config.set("editor.confirmCheckoutHeadRevision", false);
        editor.setCursorBufferPosition([0, 0]);
        editor.insertText("---\n");
        expect(editor.lineTextForBufferRow(0)).toBe("---");
        waitsForPromise(function() {
          return editor.checkoutHeadRevision();
        });
        return runs(function() {
          return expect(editor.lineTextForBufferRow(0)).toBe("var quicksort = function () {");
        });
      });
      return describe("when there's no repository for the editor's file", function() {
        return it("doesn't do anything", function() {
          editor = new TextEditor({});
          editor.setText("stuff");
          editor.checkoutHeadRevision();
          return waitsForPromise(function() {
            return editor.checkoutHeadRevision();
          });
        });
      });
    });
    describe(".moveToPreviousSubwordBoundary", function() {
      it("does not move the cursor when there is no previous subword boundary", function() {
        editor.setText('');
        editor.moveToPreviousSubwordBoundary();
        return expect(editor.getCursorBufferPosition()).toEqual([0, 0]);
      });
      it("stops at word and underscore boundaries", function() {
        editor.setText("sub_word \n");
        editor.setCursorBufferPosition([0, 9]);
        editor.moveToPreviousSubwordBoundary();
        expect(editor.getCursorBufferPosition()).toEqual([0, 8]);
        editor.moveToPreviousSubwordBoundary();
        expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
        editor.moveToPreviousSubwordBoundary();
        expect(editor.getCursorBufferPosition()).toEqual([0, 0]);
        editor.setText(" word\n");
        editor.setCursorBufferPosition([0, 3]);
        editor.moveToPreviousSubwordBoundary();
        return expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
      });
      it("stops at camelCase boundaries", function() {
        editor.setText(" getPreviousWord\n");
        editor.setCursorBufferPosition([0, 16]);
        editor.moveToPreviousSubwordBoundary();
        expect(editor.getCursorBufferPosition()).toEqual([0, 12]);
        editor.moveToPreviousSubwordBoundary();
        expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
        editor.moveToPreviousSubwordBoundary();
        return expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
      });
      it("skips consecutive non-word characters", function() {
        editor.setText("e, => \n");
        editor.setCursorBufferPosition([0, 6]);
        editor.moveToPreviousSubwordBoundary();
        expect(editor.getCursorBufferPosition()).toEqual([0, 3]);
        editor.moveToPreviousSubwordBoundary();
        return expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
      });
      it("skips consecutive uppercase characters", function() {
        editor.setText(" AAADF \n");
        editor.setCursorBufferPosition([0, 7]);
        editor.moveToPreviousSubwordBoundary();
        expect(editor.getCursorBufferPosition()).toEqual([0, 6]);
        editor.moveToPreviousSubwordBoundary();
        expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
        editor.setText("ALPhA\n");
        editor.setCursorBufferPosition([0, 4]);
        editor.moveToPreviousSubwordBoundary();
        return expect(editor.getCursorBufferPosition()).toEqual([0, 2]);
      });
      it("skips consecutive numbers", function() {
        editor.setText(" 88 \n");
        editor.setCursorBufferPosition([0, 4]);
        editor.moveToPreviousSubwordBoundary();
        expect(editor.getCursorBufferPosition()).toEqual([0, 3]);
        editor.moveToPreviousSubwordBoundary();
        return expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
      });
      return it("works with multiple cursors", function() {
        var cursor1, cursor2, ref1;
        editor.setText("curOp\ncursorOptions\n");
        editor.setCursorBufferPosition([0, 8]);
        editor.addCursorAtBufferPosition([1, 13]);
        ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
        editor.moveToPreviousSubwordBoundary();
        expect(cursor1.getBufferPosition()).toEqual([0, 3]);
        return expect(cursor2.getBufferPosition()).toEqual([1, 6]);
      });
    });
    it("works with non-English characters", function() {
      editor.setText("supTst \n");
      editor.setCursorBufferPosition([0, 9]);
      editor.moveToPreviousSubwordBoundary();
      expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
      editor.setText("supaast \n");
      editor.setCursorBufferPosition([0, 8]);
      editor.moveToPreviousSubwordBoundary();
      return expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
    });
    describe(".moveToNextSubwordBoundary", function() {
      it("does not move the cursor when there is no next subword boundary", function() {
        editor.setText('');
        editor.moveToNextSubwordBoundary();
        return expect(editor.getCursorBufferPosition()).toEqual([0, 0]);
      });
      it("stops at word and underscore boundaries", function() {
        editor.setText(" sub_word \n");
        editor.setCursorBufferPosition([0, 0]);
        editor.moveToNextSubwordBoundary();
        expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
        editor.moveToNextSubwordBoundary();
        expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
        editor.moveToNextSubwordBoundary();
        expect(editor.getCursorBufferPosition()).toEqual([0, 9]);
        editor.setText("word \n");
        editor.setCursorBufferPosition([0, 0]);
        editor.moveToNextSubwordBoundary();
        return expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
      });
      it("stops at camelCase boundaries", function() {
        editor.setText("getPreviousWord \n");
        editor.setCursorBufferPosition([0, 0]);
        editor.moveToNextSubwordBoundary();
        expect(editor.getCursorBufferPosition()).toEqual([0, 3]);
        editor.moveToNextSubwordBoundary();
        expect(editor.getCursorBufferPosition()).toEqual([0, 11]);
        editor.moveToNextSubwordBoundary();
        return expect(editor.getCursorBufferPosition()).toEqual([0, 15]);
      });
      it("skips consecutive non-word characters", function() {
        editor.setText(", => \n");
        editor.setCursorBufferPosition([0, 0]);
        editor.moveToNextSubwordBoundary();
        expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
        editor.moveToNextSubwordBoundary();
        return expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
      });
      it("skips consecutive uppercase characters", function() {
        editor.setText(" AAADF \n");
        editor.setCursorBufferPosition([0, 0]);
        editor.moveToNextSubwordBoundary();
        expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
        editor.moveToNextSubwordBoundary();
        expect(editor.getCursorBufferPosition()).toEqual([0, 6]);
        editor.setText("ALPhA\n");
        editor.setCursorBufferPosition([0, 0]);
        editor.moveToNextSubwordBoundary();
        return expect(editor.getCursorBufferPosition()).toEqual([0, 2]);
      });
      it("skips consecutive numbers", function() {
        editor.setText(" 88 \n");
        editor.setCursorBufferPosition([0, 0]);
        editor.moveToNextSubwordBoundary();
        expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
        editor.moveToNextSubwordBoundary();
        return expect(editor.getCursorBufferPosition()).toEqual([0, 3]);
      });
      return it("works with multiple cursors", function() {
        var cursor1, cursor2, ref1;
        editor.setText("curOp\ncursorOptions\n");
        editor.setCursorBufferPosition([0, 0]);
        editor.addCursorAtBufferPosition([1, 0]);
        ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1];
        editor.moveToNextSubwordBoundary();
        expect(cursor1.getBufferPosition()).toEqual([0, 3]);
        return expect(cursor2.getBufferPosition()).toEqual([1, 6]);
      });
    });
    it("works with non-English characters", function() {
      editor.setText("supTst \n");
      editor.setCursorBufferPosition([0, 0]);
      editor.moveToNextSubwordBoundary();
      expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
      editor.setText("supaast \n");
      editor.setCursorBufferPosition([0, 0]);
      editor.moveToNextSubwordBoundary();
      return expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
    });
    describe(".selectToPreviousSubwordBoundary", function() {
      return it("selects subwords", function() {
        var ref1, selection1, selection2, selection3, selection4;
        editor.setText("");
        editor.insertText("_word\n");
        editor.insertText(" getPreviousWord\n");
        editor.insertText("e, => \n");
        editor.insertText(" 88 \n");
        editor.setCursorBufferPosition([0, 5]);
        editor.addCursorAtBufferPosition([1, 7]);
        editor.addCursorAtBufferPosition([2, 5]);
        editor.addCursorAtBufferPosition([3, 3]);
        ref1 = editor.getSelections(), selection1 = ref1[0], selection2 = ref1[1], selection3 = ref1[2], selection4 = ref1[3];
        editor.selectToPreviousSubwordBoundary();
        expect(selection1.getBufferRange()).toEqual([[0, 1], [0, 5]]);
        expect(selection1.isReversed()).toBeTruthy();
        expect(selection2.getBufferRange()).toEqual([[1, 4], [1, 7]]);
        expect(selection2.isReversed()).toBeTruthy();
        expect(selection3.getBufferRange()).toEqual([[2, 3], [2, 5]]);
        expect(selection3.isReversed()).toBeTruthy();
        expect(selection4.getBufferRange()).toEqual([[3, 1], [3, 3]]);
        return expect(selection4.isReversed()).toBeTruthy();
      });
    });
    describe(".selectToNextSubwordBoundary", function() {
      return it("selects subwords", function() {
        var ref1, selection1, selection2, selection3, selection4;
        editor.setText("");
        editor.insertText("word_\n");
        editor.insertText("getPreviousWord\n");
        editor.insertText("e, => \n");
        editor.insertText(" 88 \n");
        editor.setCursorBufferPosition([0, 1]);
        editor.addCursorAtBufferPosition([1, 7]);
        editor.addCursorAtBufferPosition([2, 2]);
        editor.addCursorAtBufferPosition([3, 1]);
        ref1 = editor.getSelections(), selection1 = ref1[0], selection2 = ref1[1], selection3 = ref1[2], selection4 = ref1[3];
        editor.selectToNextSubwordBoundary();
        expect(selection1.getBufferRange()).toEqual([[0, 1], [0, 4]]);
        expect(selection1.isReversed()).toBeFalsy();
        expect(selection2.getBufferRange()).toEqual([[1, 7], [1, 11]]);
        expect(selection2.isReversed()).toBeFalsy();
        expect(selection3.getBufferRange()).toEqual([[2, 2], [2, 5]]);
        expect(selection3.isReversed()).toBeFalsy();
        expect(selection4.getBufferRange()).toEqual([[3, 1], [3, 3]]);
        return expect(selection4.isReversed()).toBeFalsy();
      });
    });
    describe(".deleteToBeginningOfSubword", function() {
      return it("deletes subwords", function() {
        var cursor1, cursor2, cursor3, cursor4, ref1;
        editor.setText("");
        editor.insertText("_word\n");
        editor.insertText(" getPreviousWord\n");
        editor.insertText("e, => \n");
        editor.insertText(" 88 \n");
        editor.setCursorBufferPosition([0, 5]);
        editor.addCursorAtBufferPosition([1, 7]);
        editor.addCursorAtBufferPosition([2, 5]);
        editor.addCursorAtBufferPosition([3, 3]);
        ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1], cursor3 = ref1[2], cursor4 = ref1[3];
        editor.deleteToBeginningOfSubword();
        expect(buffer.lineForRow(0)).toBe('_');
        expect(buffer.lineForRow(1)).toBe(' getviousWord');
        expect(buffer.lineForRow(2)).toBe('e,  ');
        expect(buffer.lineForRow(3)).toBe('  ');
        expect(cursor1.getBufferPosition()).toEqual([0, 1]);
        expect(cursor2.getBufferPosition()).toEqual([1, 4]);
        expect(cursor3.getBufferPosition()).toEqual([2, 3]);
        expect(cursor4.getBufferPosition()).toEqual([3, 1]);
        editor.deleteToBeginningOfSubword();
        expect(buffer.lineForRow(0)).toBe('');
        expect(buffer.lineForRow(1)).toBe(' viousWord');
        expect(buffer.lineForRow(2)).toBe('e ');
        expect(buffer.lineForRow(3)).toBe(' ');
        expect(cursor1.getBufferPosition()).toEqual([0, 0]);
        expect(cursor2.getBufferPosition()).toEqual([1, 1]);
        expect(cursor3.getBufferPosition()).toEqual([2, 1]);
        expect(cursor4.getBufferPosition()).toEqual([3, 0]);
        editor.deleteToBeginningOfSubword();
        expect(buffer.lineForRow(0)).toBe('');
        expect(buffer.lineForRow(1)).toBe('viousWord');
        expect(buffer.lineForRow(2)).toBe('  ');
        expect(buffer.lineForRow(3)).toBe('');
        expect(cursor1.getBufferPosition()).toEqual([0, 0]);
        expect(cursor2.getBufferPosition()).toEqual([1, 0]);
        expect(cursor3.getBufferPosition()).toEqual([2, 0]);
        return expect(cursor4.getBufferPosition()).toEqual([2, 1]);
      });
    });
    describe(".deleteToEndOfSubword", function() {
      return it("deletes subwords", function() {
        var cursor1, cursor2, cursor3, cursor4, ref1;
        editor.setText("");
        editor.insertText("word_\n");
        editor.insertText("getPreviousWord \n");
        editor.insertText("e, => \n");
        editor.insertText(" 88 \n");
        editor.setCursorBufferPosition([0, 0]);
        editor.addCursorAtBufferPosition([1, 0]);
        editor.addCursorAtBufferPosition([2, 2]);
        editor.addCursorAtBufferPosition([3, 0]);
        ref1 = editor.getCursors(), cursor1 = ref1[0], cursor2 = ref1[1], cursor3 = ref1[2], cursor4 = ref1[3];
        editor.deleteToEndOfSubword();
        expect(buffer.lineForRow(0)).toBe('_');
        expect(buffer.lineForRow(1)).toBe('PreviousWord ');
        expect(buffer.lineForRow(2)).toBe('e, ');
        expect(buffer.lineForRow(3)).toBe('88 ');
        expect(cursor1.getBufferPosition()).toEqual([0, 0]);
        expect(cursor2.getBufferPosition()).toEqual([1, 0]);
        expect(cursor3.getBufferPosition()).toEqual([2, 2]);
        expect(cursor4.getBufferPosition()).toEqual([3, 0]);
        editor.deleteToEndOfSubword();
        expect(buffer.lineForRow(0)).toBe('');
        expect(buffer.lineForRow(1)).toBe('Word ');
        expect(buffer.lineForRow(2)).toBe('e,');
        expect(buffer.lineForRow(3)).toBe(' ');
        expect(cursor1.getBufferPosition()).toEqual([0, 0]);
        expect(cursor2.getBufferPosition()).toEqual([1, 0]);
        expect(cursor3.getBufferPosition()).toEqual([2, 2]);
        return expect(cursor4.getBufferPosition()).toEqual([3, 0]);
      });
    });
    describe('gutters', function() {
      describe('the TextEditor constructor', function() {
        return it('creates a line-number gutter', function() {
          var lineNumberGutter;
          expect(editor.getGutters().length).toBe(1);
          lineNumberGutter = editor.gutterWithName('line-number');
          expect(lineNumberGutter.name).toBe('line-number');
          return expect(lineNumberGutter.priority).toBe(0);
        });
      });
      return describe('::addGutter', function() {
        it('can add a gutter', function() {
          var gutter, options;
          expect(editor.getGutters().length).toBe(1);
          options = {
            name: 'test-gutter',
            priority: 1
          };
          gutter = editor.addGutter(options);
          expect(editor.getGutters().length).toBe(2);
          return expect(editor.getGutters()[1]).toBe(gutter);
        });
        return it("does not allow a custom gutter with the 'line-number' name.", function() {
          return expect(editor.addGutter.bind(editor, {
            name: 'line-number'
          })).toThrow();
        });
      });
    });
    describe('::decorateMarker', function() {
      var marker;
      marker = [][0];
      beforeEach(function() {
        return marker = editor.markBufferRange([[1, 0], [1, 0]]);
      });
      it("casts 'gutter' type to 'line-number' unless a gutter name is specified.", function() {
        var customGutterDecoration, lineNumberDecoration;
        jasmine.snapshotDeprecations();
        lineNumberDecoration = editor.decorateMarker(marker, {
          type: 'gutter'
        });
        customGutterDecoration = editor.decorateMarker(marker, {
          type: 'gutter',
          gutterName: 'custom'
        });
        expect(lineNumberDecoration.getProperties().type).toBe('line-number');
        expect(lineNumberDecoration.getProperties().gutterName).toBe('line-number');
        expect(customGutterDecoration.getProperties().type).toBe('gutter');
        expect(customGutterDecoration.getProperties().gutterName).toBe('custom');
        return jasmine.restoreDeprecationsSnapshot();
      });
      it('reflects an added decoration when one of its custom gutters is decorated.', function() {
        var decoration, gutter, gutterDecorations;
        gutter = editor.addGutter({
          'name': 'custom-gutter'
        });
        decoration = gutter.decorateMarker(marker, {
          "class": 'custom-class'
        });
        gutterDecorations = editor.getDecorations({
          type: 'gutter',
          gutterName: 'custom-gutter',
          "class": 'custom-class'
        });
        expect(gutterDecorations.length).toBe(1);
        return expect(gutterDecorations[0]).toBe(decoration);
      });
      return it('reflects an added decoration when its line-number gutter is decorated.', function() {
        var decoration, gutterDecorations;
        decoration = editor.gutterWithName('line-number').decorateMarker(marker, {
          "class": 'test-class'
        });
        gutterDecorations = editor.getDecorations({
          type: 'line-number',
          gutterName: 'line-number',
          "class": 'test-class'
        });
        expect(gutterDecorations.length).toBe(1);
        return expect(gutterDecorations[0]).toBe(decoration);
      });
    });
    describe('::observeGutters', function() {
      var callback, payloads, ref1;
      ref1 = [], payloads = ref1[0], callback = ref1[1];
      beforeEach(function() {
        payloads = [];
        return callback = function(payload) {
          return payloads.push(payload);
        };
      });
      it('calls the callback immediately with each existing gutter, and with each added gutter after that.', function() {
        var gutter1, gutter2, lineNumberGutter;
        lineNumberGutter = editor.gutterWithName('line-number');
        editor.observeGutters(callback);
        expect(payloads).toEqual([lineNumberGutter]);
        gutter1 = editor.addGutter({
          name: 'test-gutter-1'
        });
        expect(payloads).toEqual([lineNumberGutter, gutter1]);
        gutter2 = editor.addGutter({
          name: 'test-gutter-2'
        });
        return expect(payloads).toEqual([lineNumberGutter, gutter1, gutter2]);
      });
      it('does not call the callback when a gutter is removed.', function() {
        var gutter;
        gutter = editor.addGutter({
          name: 'test-gutter'
        });
        editor.observeGutters(callback);
        payloads = [];
        gutter.destroy();
        return expect(payloads).toEqual([]);
      });
      return it('does not call the callback after the subscription has been disposed.', function() {
        var subscription;
        subscription = editor.observeGutters(callback);
        payloads = [];
        subscription.dispose();
        editor.addGutter({
          name: 'test-gutter'
        });
        return expect(payloads).toEqual([]);
      });
    });
    describe('::onDidAddGutter', function() {
      var callback, payloads, ref1;
      ref1 = [], payloads = ref1[0], callback = ref1[1];
      beforeEach(function() {
        payloads = [];
        return callback = function(payload) {
          return payloads.push(payload);
        };
      });
      it('calls the callback with each newly-added gutter, but not with existing gutters.', function() {
        var gutter;
        editor.onDidAddGutter(callback);
        expect(payloads).toEqual([]);
        gutter = editor.addGutter({
          name: 'test-gutter'
        });
        return expect(payloads).toEqual([gutter]);
      });
      return it('does not call the callback after the subscription has been disposed.', function() {
        var subscription;
        subscription = editor.onDidAddGutter(callback);
        payloads = [];
        subscription.dispose();
        editor.addGutter({
          name: 'test-gutter'
        });
        return expect(payloads).toEqual([]);
      });
    });
    return describe('::onDidRemoveGutter', function() {
      var callback, payloads, ref1;
      ref1 = [], payloads = ref1[0], callback = ref1[1];
      beforeEach(function() {
        payloads = [];
        return callback = function(payload) {
          return payloads.push(payload);
        };
      });
      it('calls the callback when a gutter is removed.', function() {
        var gutter;
        gutter = editor.addGutter({
          name: 'test-gutter'
        });
        editor.onDidRemoveGutter(callback);
        expect(payloads).toEqual([]);
        gutter.destroy();
        return expect(payloads).toEqual(['test-gutter']);
      });
      return it('does not call the callback after the subscription has been disposed.', function() {
        var gutter, subscription;
        gutter = editor.addGutter({
          name: 'test-gutter'
        });
        subscription = editor.onDidRemoveGutter(callback);
        subscription.dispose();
        gutter.destroy();
        return expect(payloads).toEqual([]);
      });
    });
  });

}).call(this);
