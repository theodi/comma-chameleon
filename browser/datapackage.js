global.electron = require('electron')

global.BrowserWindow = electron.BrowserWindow
global.Dialog = electron.dialog;

var Fs = require('fs');
var ipc = require("electron").ipcMain;
var path = require('path');

//var exports = module.exports = {};


var exportdata = function() {
  var window = BrowserWindow.getFocusedWindow();

  datapackage = new BrowserWindow({width: 450, height: 600});
  datapackage.loadURL('file://' + __dirname + '/../comma-chameleon/views/datapackage.html');

  datapackage.on('closed', function() {
    datapackage = null;
  });

  //there follows some horrible async
  //my understanding of why async is as follows - we have no controllers / model structure to control the data mgmt
  //ergo to ensure we are getting the right data for the correct CSV we are reliant on the Browser.getFocusedWindow() method
  //at two points in this long method it is necessary to ensure that this is the intended window, when the header row data is sought
  //and when the CSV to be saved to the package is retrieved by the dialog module



  ipc.once('sendDatapackage', function(e, data, includeHeaders) {
    // data here is the object generated by filling out the form, e is event param generated by using IPC
    //console.log("at begin of function this is data "+JSON.stringify(data,null, 2));
    var currentFileName = window.getTitle();
    var suggestedFileName = path.basename(currentFileName).replace('.csv', '');

    var thatData = data;
    // writing this assignment because the logic of the closure below reminds me of 'this' and 'that'

    // issue calls to get the JSON rendering of the header row
    if(includeHeaders === "true"){
      window.webContents.send('schemaFromHeaders');
      ipc.on('jsonHeaders', function(event, json){
        //assign the headers to the JSON datapackage
        datapackageJson(thatData, json);
        //console.log("currently executing within the IPC function that retrieves the headers");
        //thatData["fields"] = json["fields"];
        //return data;
      });
    } else {
      datapackageJson(thatData);
      //return data;
    }
    //console.log("this is the data immediately after the includeHeaders conditional "+JSON.stringify(data));
    //var data = datapackageJson(data);

    Dialog.showSaveDialog({
      defaultPath: suggestedFileName+".zip",
      //defaultPath: includeHeaders,
      filters: [
        { name: 'text', extensions: ['zip'] }
      ],
      //defaultPath: 'datapackage.zip'
    }, function (fileName) {
      if (fileName === undefined) return;
      datapackage.close();
      window.webContents.send('getCSV');

      ipc.once('sendCSV', function(e, csv) {
        //console.log("this is the point right before zipping up data has not be reassigned ONCE: data - "+JSON.stringify(data,null, 2));
        generateDatapackage(fileName, data, csv)
      });
    });
  });

  ipc.once('datapackageCanceled', function() {
    datapackage.close();
  });
}

function datapackageJson(data_arg, headers) {
  //console.log(data);
  data_arg.keywords = data_arg.keywords.split(",");
  //console.log(data.keywords);
  data_arg.resources = [
    {
      "name": data_arg.name,
      "path": "data/" + data_arg.name + ".csv",
      "mediatype": "text/csv",
      "schema": headers
    }
  ]
  return data_arg
}

function generateDatapackage(fileName, data_arg, csv) {
  // this function is only triggered after the user confirms the name of what they wish to save the package as
  //console.log("within async triggered generate data package function "+data_arg);
  zip = new require('node-zip')();
  zip.file('datapackage.json', JSON.stringify(data_arg,null, 2));
  zip.file('data/' + data_arg.name + '.csv', csv);
  zipData = zip.generate({base64:false,compression:'DEFLATE'});
  Fs.writeFileSync(fileName, zipData, 'binary');
}

// define interface to module
module.exports = {
  exportDatapackage: exportdata,
};
if (process.env.NODE_ENV === 'test') {
  console.log("private testing enabled");
  // now I need to work out how to access environment
  module.exports._private = {
    inputToVocab: datapackageJson,
    zipPackage: generateDatapackage
  }
} else {
  console.log("dev environment");
}
